
# R script for analysing raw counts of keratinocytes
# Author: Sidney van der Zande (s1033266)
# Contact: sidney.vanderzande@ru.nl

#Version 1.3: Leave out scRNA data

```{r}

##Load in the required packages
#For differential gene analysis and plotting
library("DESeq2")
library("tidyverse")
library("ggrepel")
library("UpSetR")
library("EDASeq")
library("ggbreak")
library("ggsignif")
library("cowplot")
library("patchwork")
#For heatmapping and making color scales
library("ComplexHeatmap")
library("circlize")
library("RColorBrewer")
#For gene ontology analysis/plotting
library("clusterProfiler")
library("DOSE")
library("org.Hs.eg.db")
library("AnnotationDbi")
library("enrichplot")
library("pathview")
library("biomaRt")
print("Done loading packages, proceed to analysis")

sessionInfo()

#Make a results directory for today's date
workdir <- "/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/"
dateoftoday <- gsub("-", "", as.character(Sys.Date()))
resultsdir <- paste0(workdir, dateoftoday)
system(paste("mkdir -p ", resultsdir))
setwd(resultsdir)

#Make a PDF in which the results will be
pdf(paste(resultsdir,'ALL_KC_v3.pdf',sep="/") ,width=6,height=7,paper='special')

#Load in the primary counts, remove row numbers and duplicated gene names
cts_primary <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmedKC_primary.csv", header = TRUE, sep = ",")
cts_primary <- subset(cts_primary, select = -c(1))
cts_primary <- cts_primary[!duplicated(cts_primary$Gene.name),]

#Load in the bulk RNA-seq TERT counts, remove duplicate gene names and remove the TERT LSC samples
cts_TERT_bulk <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmed_0906_NTERT.csv", header = TRUE, sep = ";")
cts_TERT_bulk <- cts_TERT_bulk[!duplicated(cts_TERT_bulk$Gene.name),]
cts_TERT_bulk <- cts_TERT_bulk[,1:3]

#Merging primary and TERT tables to form one count table
cts <- inner_join(cts_primary, cts_TERT_bulk, by="Gene.name")

#Make a count table data frame out of the count matrix and remove gene names
countData <- as.data.frame(cts[,-1])
rownames(countData) <- cts[,1]

#As we are not interested in non-expressed genes, we remove all genes with no counts in all conditions
countData <- countData[as.vector(rowSums(unname(countData)))>0,]

#Metadata: specify the conditions of your experiments (which experiment belongs to which condition, wt or TERT)
colData <- data.frame(c("PKC_1", "PKC_2", "KC_TERT_1", "KC_TERT_2"), c("wt", "wt", "TERT", "TERT"))

colnames(colData) <- c("experiment", "conditions")

#DESeq2, design is the metadata (from the colData) you want to compare. It will also make a plot of the dispersion estimates and the fitting.
dds <- DESeqDataSetFromMatrix(countData = countData, colData = colData , design = ~ conditions)
dds <- DESeq(dds)
plotDispEsts(dds)
resultsNames(dds)

#Store your results and save it to the server
res <- results(dds)
result_wt_vs_TERT_all <- as.data.frame(res)
#Here, I invert the log2FoldChange to represent changes of TERT compared to wt and not the other way around
result_wt_vs_TERT_all$log2FoldChange <- -result_wt_vs_TERT_all$log2FoldChange
#Store the DESeq2 result as a .tsv
write.table(result_wt_vs_TERT_all, file = paste0(resultsdir,'/wt_vs_TERT_KC_DESeq2_v3.tsv'), sep= "\t", row.names=TRUE, col.names =TRUE)

#Combine the count table and the differential gene analysis from DESeq2
result_wt_vs_TERT_all$Gene.name <- rownames(result_wt_vs_TERT_all)
joined_results <- inner_join(cts, result_wt_vs_TERT_all, by="Gene.name")
#Remove the Gene.name column and set gene names as row names
rownames(joined_results) <- joined_results[,1]
joined_results <- subset(joined_results, select = -c(1))
#Create a column of the absolute log2 Fold Change for easy filtering and selecting
joined_results$abslog2FoldChange <- abs(joined_results$log2FoldChange)

#Z-score calculation (vst normalisation) of the results from the DESeq2 object
vst_dds <- vst(dds)
vsd <- assay(vst_dds)
#Scale the rows of the resulting object
z <- t(scale(t(vsd)))
#Name the resulting columns and add these to the results table
colnames(z) <- c("z_PKC_1","z_PKC_2", "z_KC_TERT_1","z_KC_TERT_2")
joined_results <- cbind(joined_results,z)
joined_results$gene.name <- rownames(joined_results)

##TPM normalisation
#Import a .tsv file containing genes and their exonic lengths
gene_lengths <- read.csv("/scratch/szande_jarts/data/idgl.tsv", header = TRUE, sep= "\t")

#Remove NA values
gene_lengths <- na.omit(gene_lengths)

#Add a set of genes that are essential for further analyses, to ensure these are present in the data
addition <- data.frame(c("TP63", "FLG","PAX6","KRT14","LORICRIN","TGM1"), c(7479,12793,20639,2255,1245,3735))
colnames(addition) <- c("Gene.name", "Length")
gene_lengths <- rbind(gene_lengths, addition)

#Take the minimum length for each gene
gene_lengths_new <- gene_lengths %>%
  group_by(Gene.name) %>% 
  summarise(MinLength = min(Length))

#Merge gene lengths to the count matrix and remove gene names
TPM <- merge(cts, gene_lengths_new)
rownames(TPM) <- TPM[,1]
TPM <- TPM[,2:6]

#Calculate the RPK as follows: count/gene length
TPM[,1:4] = TPM[,1:4]/TPM[,5]
#If counts are zero, this calculation will give NA values and errors later on. Replace NA values by 0.
TPM[is.na(TPM)] <- 0
#Calculate the "per million" scaling factor by summing up all counts in a sample and dividing by a million (10⁶)
rowsums <- c((colSums(TPM[,c(1:4)]))/1000000)
#Divide the RPK values by the scaling factor to obtain TPM values
TPM <- sweep(TPM[,1:4], 2, rowsums, FUN= "/")
#Add back the gene names as a column for easy searching
TPM2 <- TPM
TPM2$gene <- rownames(TPM)

#Preparing data for volcano plot by adding a label showing if the gene is differential
joined_results$diffexpressed <- "No change"
# if log2FoldChange > 1 and padj < 0.05, set the label as "UP" 
joined_results$diffexpressed[joined_results$log2FoldChange > 1 & joined_results$padj < 0.05] <- "Up"
# if log2FoldChange < -1 and padj < 0.05, set the labelas "DOWN"
joined_results$diffexpressed[joined_results$log2FoldChange < -1 & joined_results$padj < 0.05] <- "Down"

#Specify the colours that will be used for each label in the plot
ggplotcolors <- c("blue", "red", "gray")
names(ggplotcolors) <- c("Down", "Up", "No change")

#Assigning labels (gene names) to the top 6 differential and top 5 significant genes
joined_results$label <- NA
#Order the genes based on their log2 fold change
joined_results <- joined_results[order(joined_results$log2FoldChange),]
#Add gene name labels to the 6 genes with the highest log2 fold change (3 most positive and 3 most negative)
joined_results$label[c(1:3, 22286:22288)] <- joined_results$gene.name[c(1:3, 22286:22288)]
#Do the same for the top 5 most signficant genes (based on padj)
joined_results <- joined_results[order(joined_results$padj),]
joined_results$label[c(1:5)] <- joined_results$gene.name[c(1:5)]

#Volcano plot, with lines at the significance cutoffs and labels for the extremely significant/differential genes
volcano <- ggplot(joined_results, aes(x=log2FoldChange, y=-log10(padj), col=diffexpressed, label=label)) + geom_point() + ggtitle("Volcano plot of N/TERT compared to wildtype of KC") + geom_vline(xintercept=c(-1, 1), col="black") +
        geom_hline(yintercept=-log10(0.05), col="black") + scale_colour_manual(values = ggplotcolors) + geom_text_repel(box.padding=0.5, max.overlaps = Inf)
volcano

#Filtering steps: padj<0.05 and remove rows with NA values in their padj
result_wt_vs_TERT_padj <- joined_results[joined_results$padj<0.05,]
result_wt_vs_TERT_padj <- result_wt_vs_TERT_padj[!is.na(result_wt_vs_TERT_padj$padj),]

#Export the genes that are differentially expressed with a padj<0.05, in descending order of log2FoldChange
genes <- result_wt_vs_TERT_padj[order(-result_wt_vs_TERT_padj$log2FoldChange),]
genes <- c(row.names(genes))
#Remove any unnecessary spacing between the gene names in the vector to avoid errors
genes <- gsub(" ", "", genes) 
write.table(genes, file = paste0(resultsdir,'/wt_vs_TERT_KC_genes_v3.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Obtain the z-scores for the genes that meet the above criteria and order based on the z-score for PKC_1
z_padj <- as.data.frame(c(result_wt_vs_TERT_padj[12:15]))
rownames(z_padj) <- row.names(result_wt_vs_TERT_padj)
z_padj <- data.matrix(z_padj, rownames.force = NA)
z_padj <- z_padj[order(z_padj[,1]),]

# Clustering (binary data) for UpSet plot: calculate average z-scores for the primary and TERT conditions
z_padj_binary <- as.data.frame(z_padj)
z_padj_binary$average_wt <- (rowSums(z_padj[,1:2]))/2
z_padj_binary$average_TERT <- (rowSums(z_padj[,3:4]))/2
# if the average z-score of the primary condition > 0, set as "1" 
z_padj_binary$average_wt[z_padj_binary$average_wt > 0 ] <- 1
# if the average z-score of the primary condition < 0, set as "0" 
z_padj_binary$average_wt[z_padj_binary$average_wt < 0 ] <- 0
#repeat for the other condition (TERT)
z_padj_binary$average_TERT[z_padj_binary$average_TERT > 0 ] <- 1
z_padj_binary$average_TERT[z_padj_binary$average_TERT < 0 ] <- 0

#Make the UpSet plot
upset(z_padj_binary)

##Heatmapping of padj<0.05 genes
#Define the colors of the heatmap
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))
#Order the genes based on their z-score in the PKC_1 condition
z_padj <- z_padj[order(z_padj[,1]),]
#Label the 10 genes with the highest/lowest LSC_1 z-score
anno_padj = anno_mark(at = c(1:10,6006:6015), labels = rownames(z_padj[c(1:10 ,6006:6015),]), which = "row")
#Make the heatmap using the previously specified colors and labels
htpadj <- Heatmap(z_padj, name="z-score", column_title = "Heatmap of significant genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_padj)

#I see two clusters in the padj-filtered heatmap, namely genes upregulated in TERT and genes downregulated in TERT. Therefore, I separate the heatmap based on km=2.
htpadj_cluster <- Heatmap(z_padj, km=2,  name="z-score", column_title = "Heatmap of significant genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark=anno_padj)
htpadj_cluster <- draw(htpadj_cluster)
genes_htpadj <- row_order(htpadj_cluster)
#I assign the genes based on their respective cluster in the heatmap
genes_TERT_high <- genes_htpadj[[2]]
genes_TERT_high <- rownames(z_padj)[genes_TERT_high]
genes_TERT_low <- genes_htpadj[[1]]
genes_TERT_low <- rownames(z_padj)[genes_TERT_low]

#Filter the padj filtered dataset based on log2FoldChange>1
result_wt_vs_TERT_logfilter <- result_wt_vs_TERT_padj[result_wt_vs_TERT_padj$abslog2FoldChange >= 1,]

#Again, obtain z-scores for the genes that meet these criteria
z_logfilter <- as.data.frame(c(result_wt_vs_TERT_logfilter[12:15]))
rownames(z_logfilter) <- row.names(result_wt_vs_TERT_logfilter)
z_logfilter <- data.matrix(z_logfilter, rownames.force = NA)
z_logfilter <- z_logfilter[order(z_logfilter[,1]),]

##Heatmapping of padj<0.05 & log2FC filtered genes
#Define the colors of the heatmap
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))
#Make labels for genes with highest/lowest LSC_1 z-scores
anno_logfilter = anno_mark(at = c(1:10, 5067:5076), labels = rownames(z_logfilter[c(1:10 , 5067:5076),]), which = "row")
#Make the heatmap using the previously specified colors and labels
htlog <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant differentially expressed genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark= anno_logfilter)

#Export the list of log2>1 and padj<0.05 genes ordered on log2FC
genes_2 <- result_wt_vs_TERT_logfilter[order(-result_wt_vs_TERT_logfilter$log2FoldChange),]
genes_2 <- c(row.names(genes_2))
genes_2 <- gsub(" ", "", genes_2) 
write.table(genes_2, file = paste0(resultsdir,'/wt_vs_TERT_KC_genes_2_v3.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Find the differential genes up/downregulated in TERT using the heatmap as done before
htlog_cluster <- Heatmap(z_logfilter, km=2, show_row_names = FALSE ,name="z-score", column_title = "Heatmap of differential significant genes", col = f4,  row_names_gp = gpar(fontsize = 5)) 
htlog_cluster <- draw(htlog_cluster)
genes_htlog <- row_order(htlog_cluster)
genes_TERT_high_log <- genes_htlog[[2]]
genes_TERT_high_log <- rownames(z_logfilter)[genes_TERT_high_log]
genes_TERT_low_log <- genes_htlog[[1]]
genes_TERT_low_log <- rownames(z_logfilter)[genes_TERT_low_log]

##Find specified genes of interest in your heatmap
find_KC <- c("KRT5","KRT14" ,"IGFBP3", "MCM3", "IVL", "LORICRIN", "FLG", "TGM1", "TP63")

#Specify in what dataset you want to find these genes, in this case z_logfilter
find_KC_row <- which(rownames(z_logfilter)%in% find_KC, arr.ind = TRUE)

#Make labels for these genes
anno_kc = anno_mark(at = find_KC_row, labels = find_KC , which = "row")
#Make the heatmap. The genes are not in the correct order yet since the heatmap does not have the same order as the vector of gene names
HTkc <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant differential genes indicating keratinocyte markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_kc)
#Because of the incorrect order, we have to reorder z_logfilter based on the order of rows in the heatmap
row_order(HTkc)
z_logfilter <- z_logfilter[row_order(HTkc),]
#Then, we can find back the genes in the correct order, make the labels, and specify the heatmap
find_KC <- find_KC[order(match(find_KC,rownames(z_logfilter)))]
find_KC_row <- which(rownames(z_logfilter)%in% find_KC, arr.ind = TRUE)
anno_kc = anno_mark(at = find_KC_row, labels = find_KC , which = "row")
HTkc <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant differential genes indicating keratinocyte markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_kc)
draw(HTkc)

#We now want to find the TPM values for all these genes. 
find_KC <- c("KRT5","KRT14" ,"IGFBP3", "MCM3", "IVL", "LORICRIN", "FLG", "TGM1", "TP63")

condition_vector <- c("PKC_1", "PKC_2", "KC_TERT_1", "KC_TERT_2")
find_set_KC <- NULL

#I specify a loop: for every gene in the find_LSC vector, it finds the TPM values, names of the samples, name of the gene, and the padj value.
#It then combines these for every gene into a data frame, and the factor function ensures the samples are plotted in the correct order.
for (xx in unique(find_KC)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  #This line below ensures the loop does not stop if the TPM values for a gene cannot be found, but instead moves on to the next gene in the vector.
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  #Function to find the padj value for each gene
  padj <- subset(joined_results, rownames(joined_results) %in% xx)
  padj <- padj$padj
  #Make the dataframe holding the information for a single gene
  df <- data.frame(TPM=val3, condition = colnames(val),gene=xx, padj = padj)
  #This dataframe will hold the requested data for all genes
  find_set_KC <- rbind(find_set_KC, df)
  #This bit of code below ensures that the TPMs are plotted in the order of the condition vector
  find_set_KC$condition = factor(find_set_KC$condition, condition_vector)
}
#Now, we can plot the gene TPMs.
#Significance bars are manually added to the significant genes. You have to specify these yourself (sorry). 
#y_position indicates the height of the significance bar, xmin defines the starting x-coordinate of the bar, xmax defines the end coordinate of the bar, annotation sets the label you want to use, and tip_length sets the lengths of the vertical tips of the bar.
p_marker_KC <- ggplot(find_set_KC, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
     stat="identity",  position = position_dodge(0.8),
    width = 0.7) + geom_signif(y_position = c(1.6,2.0,2.0,4.5,5.3,1.4,1.9,3.0,2.7), xmin = c(0.6,1.6,2.6,3.6,4.6,5.6,6.6,7.6,8.6), 
                               xmax = c(1.4,2.4, 3.4,4.4,5.4,6.4,7.4,8.4,9.4), annotation = c("*","*","*","*","*","*","*","*","*"),
                               tip_length = 0.02)

#If I want to plot the gene TPMs separately as line graphs, I first specify a line graph for every gene investigated. An asterisk is added as a label if the padj<0.05 (label=).
p1 <- ggplot(find_set_KC[1:4,], aes(x = condition, y = TPM, group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0) + geom_point()+expand_limits(y = 0)+ geom_line(color = "blue") + ggtitle ("KRT5") + scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p2 <- ggplot(find_set_KC[5:8,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0) + geom_point() +expand_limits(y = 0)+ geom_line(color = "red") + ggtitle("KRT14")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p3 <- ggplot(find_set_KC[9:12,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA)))+ geom_text(vjust = 0) + geom_point() +expand_limits(y = 0)+ geom_line(color = "green") + ggtitle("IGFBP3")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p4 <- ggplot(find_set_KC[13:16,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA)))+ geom_text(vjust = 0) + geom_point() +expand_limits(y = 0)+ geom_line(color = "yellow") + ggtitle("MCM3")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p5 <- ggplot(find_set_KC[17:20,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0)+ geom_point()+expand_limits(y = 0)+ geom_line(color = "orange") + ggtitle("IVL")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p6 <- ggplot(find_set_KC[21:24,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0)+ geom_point()+expand_limits(y = 0)+ geom_line(color = "orange") + ggtitle("LORICRIN")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p7 <- ggplot(find_set_KC[25:28,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0)+ geom_point()+expand_limits(y = 0)+ geom_line(color = "orange") + ggtitle("FLG")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p8 <- ggplot(find_set_KC[29:32,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0)+ geom_point()+expand_limits(y = 0)+ geom_line(color = "orange") + ggtitle("TGM1")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )
p9 <- ggplot(find_set_KC[33:36,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0)+ geom_point()+expand_limits(y = 0)+ geom_line(color = "orange") + ggtitle("TP63")+ scale_x_discrete(labels = c("PKC_1" = "KC 1", "PKC_2", "KC_TERT_1" = "KC TERT 1", "KC_TERT_2" = "KC TERT 2") )

#I now combine the line graphs in one overview
plot_KC <- plot_grid(p1,p2,p3,p4,p5,p6,p7,p8,p9)

#And I make a pdf of the result
pdf(paste(resultsdir,'KC_marker_TPM_v3.pdf',sep="/") ,width=6,height=7,paper='special')
p_marker_KC
plot_KC
dev.off()

#I do the same for cell cycle genes as I did for important KC markers above
cellcycle <- c("PCNA", "TOP2A", "MCM6", "MKI67", "CCND1", "CDK2", "GMNN", "AURKA", "AURKB")
find_set_cell <- NULL

for (xx in unique(cellcycle)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_cell <- rbind(find_set_cell, df)
  find_set_cell$condition = factor(find_set_cell$condition, condition_vector)
}
p_cell_KC <- ggplot(find_set_cell, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + geom_signif(y_position = c(2.1,1.9,2.3,1.8,1.6,1.3,2.2,2.3,3.4), xmin = c(0.6,1.6,2.6,3.6, 4.6,5.6,6.6,7.6,8.6), 
                               xmax = c(1.4,2.4,3.4, 4.4, 5.4,6.4,7.4,8.4,9.4), annotation = c("*","*","*", "*","*","*","*","*","*"),
                               tip_length = 0.02)

#Heatmapping the cell cycle genes
find_cell_row <- which(rownames(z_logfilter)%in% cellcycle, arr.ind = TRUE)
anno_cell = anno_mark(at = find_cell_row, labels = cellcycle , which = "row")
HTcell <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cell)
row_order(HTcell)
z_logfilter <- z_logfilter[row_order(HTcell),]
cellcycle <- cellcycle[order(match(cellcycle,rownames(z_logfilter)))]
find_cell_row <- which(rownames(z_logfilter)%in% cellcycle, arr.ind = TRUE)
anno_cell = anno_mark(at = find_cell_row, labels = cellcycle , which = "row")
HTcell_KC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cell)

pdf(paste(resultsdir,'KC_cellcycle_v3.pdf',sep="/") ,width=6,height=7,paper='special')
draw(HTcell_KC)
p_cell_KC
dev.off()

#-------------------------------------------------------------------------------------------------------------------------------------------------------------


#I now perform gene ontology enrichment analysis (ORA) for several of the gene clusters I defined above. I use the clusterProfiler package for this.
#It looks up all associated biological process (BP) terms for each gene in the vector and does statistical analysis on this. 
#I only include results with an adjusted p value (q value) of <0.05.

#First, for all genes with a padj<0.05
ego <- enrichGO(gene         = genes,
                OrgDb         = org.Hs.eg.db,
                keyType       = 'SYMBOL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.05,
                readable      = FALSE)

#Then, for genes with a padj <0.05 and an abslog2FC >1
ego_2 <- enrichGO(gene         = genes_2,
                  OrgDb         = org.Hs.eg.db,
                  keyType       = 'SYMBOL',
                  ont           = "BP",
                  pAdjustMethod = "BH",
                  pvalueCutoff  = 1,
                  qvalueCutoff  = 0.05,
                  readable      = FALSE)

#I plot both results in barplots
barplot(ego, showCategory=15, title = "Barplot for padj genes")

barplot(ego_2, showCategory=15, title = "Barplot for log2 genes") 

#Merging go terms based on p values, this is to combine similar terms
ego_new <- simplify(ego, cutoff = 0.9, by = "p.adjust", select_fun = min)
ego_new_2 <- simplify(ego_2, cutoff = 0.9, by = "p.adjust", select_fun = min)

#Again, I plot the results
barplot(ego_new, showCategory=15, title = "Simplified barplot for padj genes")

barplot(ego_new_2, showCategory=15, title = "Simplified barplot for log2 genes")

#Now, I analyse the differentially expressed genes separately based on up- or downregulation in TERT LSCs
#Genes upregulated in TERT
ego_high_log <- enrichGO(gene         = genes_TERT_high_log,
                  OrgDb         = org.Hs.eg.db,
                  keyType       = 'SYMBOL',
                  ont           = "BP",
                  pAdjustMethod = "BH",
                  pvalueCutoff  = 1,
                  qvalueCutoff  = 0.05,
                  readable      = FALSE)

#Genes downregulated in TERT
ego_low_log <- enrichGO(gene         = genes_TERT_low_log,
                         OrgDb         = org.Hs.eg.db,
                         keyType       = 'SYMBOL',
                         ont           = "BP",
                         pAdjustMethod = "BH",
                         pvalueCutoff  = 1,
                         qvalueCutoff  = 0.05,
                         readable      = FALSE)

#Here I plot the result of the above TERT analyses
high_log2_GO_KC <- barplot(ego_high_log, showCategory = 15, title = "Differentially upregulated genes in TERT")
low_log2_GO_KC <- barplot(ego_low_log, showCategory = 15, title = "Differentially downregulated genes in TERT")
high_log2_GO_KC
low_log2_GO_KC 

#---------------------------------------------------------------------------------------------------------------------------------------------------
##Finding genes associated with certain GO terms
#First, I extract the genes separated by their GO terms
go_genes <- data.matrix(ego_low_log@result$geneID)
#Then, i couple the GO terms to the gene sets
go_pathways <- data.matrix(ego_low_log@result$Description)
row.names(go_genes) <- go_pathways[,1]

#I can now extract all genes associated with a certain term, such as "epidermis development"
epi_genes <- go_genes[c("epidermis development"),]
#Remove any slashes that might be in the vector
epi_genes <- strsplit(epi_genes, split = "/")
#This creates a list, convert to a vector
epi_genes <- epi_genes[[1]]
#Remove any unnessecary spaces, which can cause errors with other functions if left untreated
epi_genes <- gsub(" ", "", epi_genes)
#Export the genes associated wih this GO term
write.table(epi_genes, file = paste0(resultsdir,'/wt_vs_TERT_KC_v3_epidermis_development_genes.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Here, I do the same for a different GO term, in this case "skin development"
epi_diff_genes <- go_genes[c("skin development"),]
epi_diff_genes <- strsplit(epi_diff_genes, split = "/")
epi_diff_genes <- epi_diff_genes[[1]]
epi_diff_genes <- gsub(" ", "", epi_diff_genes)
write.table(epi_diff_genes, file = paste0(resultsdir,'/wt_vs_TERT_KC_v3_skin_development_genes.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

##Plotting the two GO gene types in the heatmap of differential genes (padj and log2FC filtered)
#Designing the color scheme
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))

#specify in what dataset you want to find these genes (z_logfilter)
epi_rows <- which(rownames(z_logfilter)%in% epi_genes, arr.ind = TRUE)

#Add labels and ensure that they are at the correct position, as done for earlier heatmaps
anno_epi = anno_mark(at = epi_rows, labels = epi_genes , which = "row")
HTep <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in epidermis development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
row_order(HTep)
z_logfilter <- z_logfilter[row_order(HTep),]
epi_genes <- epi_genes[order(match(epi_genes,rownames(z_logfilter)))]
epi_rows <- which(rownames(z_logfilter)%in% epi_genes, arr.ind = TRUE)
anno_epi = anno_mark(at = epi_rows, labels = epi_genes , which = "row")
HTep <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in epidermis development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
print(HTep)

#I now do the exact same for the second GO term
epi_diff_rows <- which(rownames(z_logfilter)%in% epi_diff_genes, arr.ind = TRUE)

#heatmapping
anno_epi_diff = anno_mark(at = epi_diff_rows, labels = epi_diff_genes , which = "row")
HTepdiff <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in skin development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_diff)
row_order(HTepdiff)
z_logfilter <- z_logfilter[row_order(HTepdiff),]
epi_diff_genes <- epi_diff_genes[order(match(epi_diff_genes,rownames(z_logfilter)))]
epi_diff_rows <- which(rownames(z_logfilter)%in% epi_diff_genes, arr.ind = TRUE)
anno_epi_diff = anno_mark(at = epi_diff_rows, labels = epi_diff_genes , which = "row")
HTepdiff <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in skin development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_diff)
print(HTepdiff)

#Plot the two heatmaps at the same time
HTep+HTepdiff

#------------------------------------------------------------------------------------------------

##KEGG analysis of differential genes
#Extract the log2FoldChange of the differential genes
log2FoldChange <- as.data.frame(result_wt_vs_TERT_padj$log2FoldChange)
#Couple the log2FC to the gene name and add column names
rownames(log2FoldChange) <- rownames(result_wt_vs_TERT_padj)
colnames(log2FoldChange) <- "log2FoldChange"
#Specify which KEGG pathways you want to investigate
pathways <- c("hsa04210", "hsa04010", "hsa04115" , "hsa04014", "hsa04064","hsa04668","hsa04151","hsa04015", "hsa04310", "hsa04330")

#This is a loop that does KEGG pathway analysis on the differential genes for each pathway in the pathways vector. The result is an image that is exported to your working directory.
for (kegg in pathways)
  { pathview(gene.data = log2FoldChange, pathway.id = kegg,
             species = "hsa", gene.idtype = "SYMBOL", out.suffix = "kert.v3.padj",limit = c(-2, 2), low = list(gene = "red", cpd = "blue"), mid =
               list(gene = "gray", cpd = "gray"), high = list(gene = "green", cpd =
                                                                "yellow"),)} 
# hsa04210 = apoptosis
# hsa04010 = MAPK
# hsa04115 = p53
# hsa04014 = Ras
# hsa04064 = NF-kB
# hsa04668 = TNF
# hsa04151 = PI3K
# hsa04015 = Rap1
# hsa04310 = Wnt
# hsa04330 = Notch

#Deleting leftover KEGG files that we do not need for analysis
#If you want to delete everything: unlink("hsa*")
unlink("hsa*.xml")
unlink("hsa04210.png")
unlink("hsa04010.png")
unlink("hsa04115.png")
unlink("hsa04014.png")
unlink("hsa04064.png")
unlink("hsa04668.png")
unlink("hsa04151.png")
unlink("hsa04015.png")
unlink("hsa04310.png")
unlink("hsa04330.png")

#These are additional KEGG pathway analyses for splicing and pluripotency
kegg_checks <- c("hsa03040", "hsa04550")
for (kegg in kegg_checks)
{ pathview(gene.data = log2FoldChange, pathway.id = kegg,
         species = "hsa", gene.idtype = "SYMBOL", out.suffix = "kert.v3.padj", limit = c(-2, 2), low = list(gene = "red", cpd = "blue"), mid =
           list(gene = "gray", cpd = "gray"), high = list(gene = "green", cpd =
                                                            "yellow"),)} 
unlink("hsa*.xml")
unlink("hsa03040.png")
unlink("hsa04550.png")

#---------------------------------------------------------------------------------------------------

#Since DNA replication seems increased in TERT cells, I manually investigate if a specified set of replication genes is differentially expressed using the same techniques used before.
find_KC_fork <- c("TIPIN" , "CLSPN", "WDHD1", "CDC45")
find_set_fork <- NULL

for (xx in unique(find_KC_fork)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_fork <- rbind(find_set_fork, df)
  find_set_fork$condition = factor(find_set_fork$condition, condition_vector)
   }
find_set_fork_KC <- ggplot(find_set_fork, aes(x = gene, y = (log10(TPM+1)))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7)  + geom_signif(y_position = c(1.7,1.3,1.4), xmin = c(0.6,1.6,3.6), 
                                xmax = c(1.4,2.4,4.4), annotation = c("*","*","*"),
                                tip_length = 0.02)
find_set_fork_KC

#Design a heatmap containing both cell cycle and replication fork genes
find_cell_fork <- c(find_KC_fork, cellcycle)
find_cellfork_row <- which(rownames(z_logfilter)%in% find_cell_fork, arr.ind = TRUE)
anno_cellfork = anno_mark(at = find_cellfork_row, labels = find_cell_fork, which = "row")
HTcellfork <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle and replication fork genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cellfork)
row_order(HTcellfork)
z_logfilter <- z_logfilter[row_order(HTcellfork),]
find_cell_fork <- find_cell_fork[order(match(find_cell_fork,rownames(z_logfilter)))]
find_cellfork_row <- which(rownames(z_logfilter)%in% find_cell_fork, arr.ind = TRUE)
anno_cellfork = anno_mark(at = find_cellfork_row, labels = find_cell_fork, which = "row", labels_gp = gpar(fontsize = 18))
HTcellfork_KC <- Heatmap(z_logfilter, name="z-score",  
                          col = f4,   column_names_gp = gpar(fontsize = 20),  heatmap_legend_param = list(labels_gp = gpar(fontsize = 20), title_gp = gpar(fontsize = 24))) + rowAnnotation(mark = anno_cellfork)
draw(HTcellfork_KC)

#Add the TPM graph
find_cellfork_KC <- NULL

for (xx in unique(find_cell_fork)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_cellfork_KC <- rbind(find_cellfork_KC, df)
  find_cellfork_KC$condition = factor(find_cellfork_KC$condition, condition_vector)
}

find_cell_fork_KC <- ggplot(find_cellfork_KC, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7)  + geom_signif(y_position = c(2.1,1.9,2.3,1.7,1.8,1.3,1.6,1.3,2.2,2.3,3.4,1.4), xmin = c(0.6,1.6,2.6,3.6,4.6,5.6,6.6,7.6,8.6,9.6,11.6,12.6), 
                                xmax = c(1.4,2.4,3.4,4.4,5.4,6.4,7.4,8.4,9.4,10.4,12.4,13.4), annotation = c("*","*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*"),
                                tip_length = 0.02)

#Finding back E2F1 targets in the log filtered heatmap according to previous procedures
find_e2f1_all <- c("E2F1", "DHFR", "TK1", "CCNE1",  "RB1", "TFDP1", "RBL", "MYBL2", "CDC6", "ORC1", "CDC2", "CCND1", "TYMS")

find_e2f1_row <- which(rownames(z_logfilter)%in% find_e2f1_all, arr.ind = TRUE)
anno_e2f1 = anno_mark(at = find_e2f1_row, labels = find_e2f1_all , which = "row")
HTe2f1 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating E2F1 targets", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_e2f1)
row_order(HTe2f1)
z_logfilter <- z_logfilter[row_order(HTe2f1),]
find_e2f1_all <- find_e2f1_all[order(match(find_e2f1_all,rownames(z_logfilter)))]
find_e2f1_row <- which(rownames(z_logfilter)%in% find_e2f1_all, arr.ind = TRUE)
anno_e2f1 = anno_mark(at = find_e2f1_row, labels = find_e2f1_all , which = "row")
HTe2f1 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating E2F1 targets", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_e2f1)
draw(HTe2f1)

#Plotting the TPM values of  all found targets 
find_set_e2f1_all <- NULL

for (xx in unique(find_e2f1_all)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_e2f1_all <- rbind(find_set_e2f1_all, df)
  find_set_e2f1_all$condition = factor(find_set_e2f1_all$condition, condition_vector)
}
find_set_e2f1_KC <- ggplot(find_set_e2f1_all, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + geom_signif(y_position = c(2.3,0.9,2.5,0.9,1.0,1.2,0.6,1.4,1.3,1.5), xmin = c(0.6,1.6,2.6,3.6,4.6,5.6,6.6,7.6,9.6,10.6), 
                               xmax = c(1.4,2.4,3.4,4.4,5.4,6.4,7.4,8.4,10.4,11.4), annotation = c("*","*","*","*","*","*","*","*","*","*"),
                               tip_length = 0.02)
find_set_e2f1_KC

#-----------------------------------------------------------------------------------------------------

##PCA analysis of the samples
#Create a PDF file to store the results
pdf(paste(resultsdir,'KC_PCA_v3.pdf',sep="/") ,width=6,height=7,paper='special')
             
#Specifying the dataset you want to look at (object) and the metadata it contains (intgroup)
object <- vst_dds
intgroup <- c("conditions","experiment")

#Finding back individual PC scores for the genes. summary(pc) can give you the % of variance each PC explains.
rv = rowVars(assay(object)) 
select = order(rv, decreasing=TRUE)[seq_len(min(10000, length(rv)))]
pc = prcomp(t(assay(object)[select,]))
loadings = as.data.frame(pc$rotation)
aload = loadings
sweep(aload, 2, colSums(aload), "/")

#Generate a Scree plot, which visualises the % variance each PC explains The PC = paste0("PC", x:x ... might have to be adapted if your dataset generates a different number of PCs.)
var_explained_df <- data.frame(PC= paste0("PC",1:8),
                               var_explained=(pc$sdev)^2/sum((pc$sdev)^2))
var_explained_df <- var_explained_df[order(var_explained_df$var_explained,decreasing = TRUE),]
var_explained_df$PC <- factor(var_explained_df$PC, levels = var_explained_df$PC)

var_explained_df %>%
  ggplot(aes(x=PC,y=var_explained, group=1))+
  geom_point(size=4)+
  geom_line()+
  labs(title="Scree plot of PCA")

#This is a function to generate a PCA plot of your samples. It calculates PC scores for each gene and makes the PCA plot based on this.
plotPCA.dim <- function (object, intgroup = "conditions", ntop = 500, returnData = FALSE) 
{
  rv <- rowVars(assay(object))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
                                                     length(rv)))]
  pca <- prcomp(t(assay(object)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  if (!all(intgroup %in% names(colData(object)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }
  intgroup.df <- as.data.frame(colData(object)[, intgroup, drop = FALSE])
  group <- if (length(intgroup) > 1) {
    factor(apply(intgroup.df, 1, paste, collapse = " : "))
  }
  else {
    colData(object)[[intgroup]]
  }
  d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], PC3= pca$x[,3], PC4 =pca$x[,4], group = group, 
                  intgroup.df, name = dds@colData@listData[["experiment"]])
  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:3]
    return(d)
  }
  ggplot(d, aes(PC1, PC2, color = conditions, label = name)) +geom_point(size=3) + geom_label_repel(size=7, box.padding=0.5) + xlab(paste0("PC1: ",round(var_explained_df[1,2]*100,digits = 2),"%")) + ylab(paste0("PC2: ",round(var_explained_df[2,2]*100, digits = 2),"%"))
  #if you ever want to change which PC dimensions to look at, change the PC in the ggplot function. For example, swap out "PC2" for "PC3". This function can go up to PCA 5.
}

#Make the PCA plot based on your DESeq2 result
PCA_KC <- plotPCA.dim(vst_dds)
PCA_KC

#I now extract the PC1 scores for all genes
genes_PC1 <- aload[order(aload$PC1, decreasing=TRUE),]
genes_PC1 <- as.data.frame(aload$PC1)
genes_PC1$Gene <- rownames(aload)
colnames(genes_PC1) <- c("PC1", "Gene")
#I make a histogram to decide which PC1 values would be good cutoffs to decide if a gene significantly contributes to PC1
ggplot(genes_PC1, aes(x=PC1)) + geom_histogram(binwidth=0.0001)
#Good cut-off value is likely 0.0125 and above, -0.0125 or below
#so I make two datasets: genes with large positive PC1 scores and genes with large negative PC1 scores
genes_PC1_filtered_pos <- genes_PC1[genes_PC1$PC1>=0.0125,]
genes_PC1_filtered_neg <- genes_PC1[genes_PC1$PC1 <=-0.0125,]

#GO analysis of the genes with significant PC1 scores separated based on positive or negative contribution
ego_PC1_pos <- enrichGO(gene         = genes_PC1_filtered_pos$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

ego_PC1_neg <- enrichGO(gene         = genes_PC1_filtered_neg$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

#Visualisation of the results
PCA_pos_KC <- barplot(ego_PC1_pos, showCategory = 15, title = "Genes giving positive weight to PC1")
PCA_neg_KC <- barplot(ego_PC1_neg, showCategory = 15, title = "Genes giving negative weight to PC1")

PCA_pos_KC
PCA_neg_KC

#I make a heatmap that shows the distance between the samples
sampleDists <- dist(t(assay(vst_dds)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

#And I close off the pdf to generate a pdf for the PCA analysis
dev.off()

#---------------------------------------------------------------------------------------------
#From the CGS database, I import a csv file containing oncogenes, tumour suppressor genes (TSG), fusion genes and information about them.
oncogenes_table <- read.csv("/scratch/szande_jarts/CGS_1705", header= TRUE, sep = ",")

#Discard any genes marked as 'fusion gene', leaving only oncogenes and TSGs
oncogenes_table <- oncogenes_table %>% separate(Role.in.Cancer, c('Role.in.Cancer.1', 'Role.in.Cancer.2',"Role.in.Cancer.3"))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl('fusion', Role.in.Cancer.1))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl("fusion", Role.in.Cancer.2))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl('fusion', Role.in.Cancer.3))

#Extract the gene names, leaving out all other information
oncogenes <- oncogenes_table$Gene.Symbol

#Map these oncogenes/suppressor genes to the heatmap of differential genes
oncogenes_row <- which(rownames(z_logfilter)%in% oncogenes, arr.ind = TRUE)
anno_onco = anno_mark(at = oncogenes_row, labels = oncogenes , which = "row")
HTonco <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating oncogenes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_onco)
row_order(HTonco)
z_logfilter <- z_logfilter[row_order(HTonco),]
oncogenes <- oncogenes[order(match(oncogenes,rownames(z_logfilter)))]
oncogenes_row <- which(rownames(z_logfilter)%in% oncogenes, arr.ind = TRUE)
anno_onco = anno_mark(at = oncogenes_row, labels = oncogenes , which = "row")
HTonco <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating oncogenes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_onco)
draw(HTonco)

#Extract oncogenes that are significant and differential (log_oncogenes)
log_oncogenes <- rownames(subset(z_logfilter, rownames(z_logfilter) %in% oncogenes))

#Couple back the differential oncogenes to their role in cancer (oncogene or TSG)
log_oncogenes_info <- subset(oncogenes_table, oncogenes_table$Gene.Symbol %in% log_oncogenes)
log_oncogenes_info <- log_oncogenes_info[,c("Gene.Symbol", "Role.in.Cancer.1","Role.in.Cancer.2","Role.in.Cancer.3")]

#Get the log2 fold change and the padj for the differential oncogenes/TSGs
log_oncogenes_info2 <- subset(joined_results, rownames(joined_results) %in% log_oncogenes)
log_oncogenes_info2 <- log_oncogenes_info2[,c("log2FoldChange", "padj")]
log_oncogenes_info2$Gene.Symbol <- rownames(log_oncogenes_info2)

#Add the log2FC and the padj to the table containing the genes and their role in cancer
log_oncogenes_info <- inner_join(log_oncogenes_info, log_oncogenes_info2, by = "Gene.Symbol")

#Plot the distribution of up/down oncogenes and TSGs
#Set a label stating the gene type: oncogene, TSG or both
#Genes are oncogenes if they are only marked as oncogenes (oncogene in column 1 and no function in column 2), the same holds for TSGs.
log_oncogenes_info$gene.type <- c("oncogene_TSG")
log_oncogenes_info$gene.type[log_oncogenes_info$Role.in.Cancer.1 == "oncogene" & is.na(log_oncogenes_info$Role.in.Cancer.2) == TRUE] <- "oncogene"
log_oncogenes_info$gene.type[log_oncogenes_info$Role.in.Cancer.1 == "TSG" & is.na(log_oncogenes_info$Role.in.Cancer.2) == TRUE] <- "TSG"

#Set a second label stating if the gene is upregulated (1) or downregulated (0) based on the log2 Fold Change being above or below 0
log_oncogenes_info$expression <- NA
log_oncogenes_info$expression[log_oncogenes_info$log2FoldChange >0 ] <- 1
log_oncogenes_info$expression[log_oncogenes_info$log2FoldChange <0 ] <- 0
log_oncogenes_binary <- log_oncogenes_info[,c("gene.type","expression")]

#Separate based on gene type (oncogene, tumor suppressor, or both)
oncogenes_binary <- dplyr::filter(log_oncogenes_binary, grepl('oncogene', gene.type))
oncogenes_binary <- oncogenes_binary$expression

oncogenes_TSG_binary <- dplyr::filter(log_oncogenes_binary, grepl("oncogene_TSG", gene.type))
oncogenes_TSG_binary <- oncogenes_TSG_binary$expression

TSG_binary <- dplyr::filter(log_oncogenes_binary, grepl('TSG', gene.type))
TSG_binary <- TSG_binary$expression

#Create a dataframe stating how many genes are up- and downregulated for each gene type (oncogenes, oncogenes + TSG, TSG)
gene.type <- c("oncogene","oncogene","oncogene_TSG","oncogene_TSG","TSG","TSG")
gene.count <- c(sum(oncogenes_binary),length(oncogenes_binary)-sum(oncogenes_binary),
                sum(oncogenes_TSG_binary),length(oncogenes_TSG_binary)-sum(oncogenes_TSG_binary),
                sum(TSG_binary),
                length(TSG_binary)-sum(TSG_binary))
gene.condition <- c("TERT upregulated","TERT downregulated","TERT upregulated","TERT downregulated","TERT upregulated","TERT downregulated")
log_oncogenes_barchart <- data.frame(x=gene.type,y=gene.count, group=gene.condition)

#Plot the result in a bar chart
onco_plot <- ggplot(log_oncogenes_barchart, aes( x=x,y=y, fill = group)) + 
  geom_bar(position="stack", stat="identity") + scale_fill_manual(values=c("darkred","darkgreen"))

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Find the TPM values for a set of epithelial markers by means of the same loop as before
epithelial <-c("KRT1", "KRT3","KRT10", "KRT12","KRT13" ,
              "KRT14", "KRT15", "KRT19", "KLF4", "KLF5","KLF6","KLF7")

df_epithelial <- NULL

for (xx in unique(epithelial)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial <- rbind(df_epithelial, df)
  df_epithelial$condition = factor(df_epithelial$condition, condition_vector)
}

#Plot the epithelial markers on the heatmap of differential genes as done before
epithelial_row <- which(rownames(z_logfilter)%in% epithelial, arr.ind = TRUE)
anno_epi = anno_mark(at =epithelial_row, labels = epithelial , which = "row")
HTepi <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
row_order(HTepi)
z_logfilter <- z_logfilter[row_order(HTepi),]
epithelial <- epithelial[order(match(epithelial,rownames(z_logfilter)))]
epithelial_row <- which(rownames(z_logfilter)%in% epithelial, arr.ind = TRUE)
anno_epi = anno_mark(at =epithelial_row, labels = epithelial , which = "row")
HTepi_KC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)

p_epi1_KC <- ggplot(df_epithelial, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers") + geom_signif(y_position = c(2.9,2.2,2.4,3.2,3.7,0.7,4.5,0.6), xmin = c(0.6,1.6,2.6,4.6,5.6,7.6,8.6,10.6), 
                                                               xmax = c(1.4,2.4, 3.4,5.4,6.4,8.4,9.4,11.4), annotation = c("*","*","*","*","*","*","*","*"),
                                                               tip_length = 0.02)

#I do the same for a set of HOX genes.
#To know which HOX genes are in the count table, the function below puts every gene name starting with HOX in the count table in a vector
HOX_genes <- cts[grep("^HOX",cts$Gene.name),]
HOX_genes <- HOX_genes[,1]

epithelial_2 <- HOX_genes

df_epithelial_2 <- NULL

for (xx in unique(epithelial_2)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial_2 <- rbind(df_epithelial_2, df)
  df_epithelial_2$condition = factor(df_epithelial_2$condition, condition_vector)
}

epithelial_2_row <- which(rownames(z_logfilter)%in% epithelial_2, arr.ind = TRUE)
anno_epi_2 = anno_mark(at =epithelial_2_row, labels = epithelial_2 , which = "row")
HTepi2 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_2)
row_order(HTepi2)
z_logfilter <- z_logfilter[row_order(HTepi2),]
epithelial_2 <- epithelial_2[order(match(epithelial_2,rownames(z_logfilter)))]
epithelial_2_row <- which(rownames(z_logfilter)%in% epithelial_2, arr.ind = TRUE)
anno_epi_2 = anno_mark(at =epithelial_2_row, labels = epithelial_2 , which = "row")
HTepi2_KC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_2)

p_epi2_KC <- ggplot(df_epithelial_2, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("HOX genes")

#I do the analysis a third time for more general epithelial transcription factors (and some KC transcription factors)
epithelial_3 <- c("JUN","JUNB","TFAP2A","GRHL1","ETS2","GATA3","CEBPA","EHF")

df_epithelial_3 <- NULL

for (xx in unique(epithelial_3)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial_3 <- rbind(df_epithelial_3, df)
  df_epithelial_3$condition = factor(df_epithelial_3$condition, condition_vector)
}

epithelial_3_row <- which(rownames(z_logfilter)%in% epithelial_3, arr.ind = TRUE)
anno_epi_3 = anno_mark(at =epithelial_3_row, labels = epithelial_3 , which = "row")
HTepi3 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_3)
row_order(HTepi3)
z_logfilter <- z_logfilter[row_order(HTepi3),]
epithelial_3 <- epithelial_3[order(match(epithelial_3,rownames(z_logfilter)))]
epithelial_3_row <- which(rownames(z_logfilter)%in% epithelial_3, arr.ind = TRUE)
anno_epi_3 = anno_mark(at =epithelial_3_row, labels = epithelial_3 , which = "row")
HTepi3_KC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_3)

p_epi3_KC <- ggplot(df_epithelial_3, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers")+ geom_signif(y_position = c(1.8,2.3,1.6,1.7,2.5,3.0), xmin = c(0.6,2.6,3.6,4.6,5.6,6.6), 
                                                              xmax = c(1.4,3.4,4.4,5.4,6.4,7.4), annotation = c("*","*","*","*","*","*"),
                                                              tip_length = 0.02)

#I export the TPM plots and heatmaps of all investigated epithelial/LSC markers
pdf(paste(resultsdir,'KC_epithelial markers_v3.pdf',sep="/") ,width=7,height=7,paper='special')
draw(HTepi_KC)
p_epi1_KC
draw(HTepi2_KC)
p_epi2_KC
draw(HTepi3_KC)
p_epi3_KC
dev.off()

#Close off the results PDF
dev.off()

#END
```
