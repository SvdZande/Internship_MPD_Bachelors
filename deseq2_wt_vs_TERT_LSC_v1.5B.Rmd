
# R script for analysing raw counts of limbal stem cells
# Author: Sidney van der Zande (s1033266)
# Contact: sidney.vanderzande@ru.nl

# Version 1.5B: Added 2 additional TERT samples

```{r}

##Load in the required packages
#Packages for differential gene analysis and plotting
library("DESeq2")
library("tidyverse")
library("ggrepel")
library("UpSetR")
library("EDASeq")
library("ggbreak")
library("cowplot")
library("ggsignif")
library("patchwork")
#For heatmapping and making color scales
library("ComplexHeatmap")
library("circlize")
library("RColorBrewer")
#For gene ontology analysis/plotting
library("clusterProfiler")
library("DOSE")
library("org.Hs.eg.db")
library("AnnotationDbi")
library("enrichplot")
library("pathview")
library("biomaRt")
print("Done loading packages, proceed to analysis")

sessionInfo()

#Make a results directory for today's date
workdir <- "/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/"
dateoftoday <- gsub("-", "", as.character(Sys.Date()))
resultsdir <- paste0(workdir, dateoftoday)
system(paste("mkdir -p ", resultsdir))
setwd(resultsdir)

#Make a PDF in which the results will be
pdf(paste(resultsdir,'ALL_LSC.v2.pdf',sep="/") ,width=6,height=7,paper='special')

#Load in the primary counts, remove row numbers and duplicated gene names
cts_primary <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmedLSC_primary.csv", header = TRUE, sep = ",")
cts_primary <- subset(cts_primary, select = -c(1))
cts_primary <- cts_primary[!duplicated(cts_primary$Gene.name),]

#Load in the TERT counts, remove row numbers, the last two datasets and duplicated gene names
cts_TERT <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmedLSC_TERT.csv", header = TRUE, sep = ",")
cts_TERT <- subset(cts_TERT, select = -c(1))
cts_TERT <- subset(cts_TERT, select = -c(4:5))
colnames(cts_TERT) <- c("Gene.name", "LSC_TERT1", "LSC_TERT2")
cts_TERT <- cts_TERT[!duplicated(cts_TERT$Gene.name),]

#Add the additional TERT samples, remove duplicate gene names and merge these to the original TERT data frame
cts_TERT_2 <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmed_0906_NTERT.csv", header = TRUE, sep = ";")
cts_TERT_2 <- cts_TERT_2[,c("Gene.name","LSC_TERT_1","LSC_TERT_2")]
colnames(cts_TERT_2) <- c("Gene.name","LSC_TERT3","LSC_TERT4")
cts_TERT_2 <- cts_TERT_2[!duplicated(cts_TERT_2$Gene.name),]
cts_TERT <- inner_join(cts_TERT,cts_TERT_2, by = "Gene.name")

#Merging primary and TERT tables to form one count table
cts <- inner_join(cts_primary, cts_TERT, by="Gene.name")

#Make a count table data frame out of the count matrix and remove gene names
countData <- as.data.frame(cts[,-1])
rownames(countData) <- cts[,1]

#Remove rows with only zeroes in them (aka remove genes not expressed in any condition)
countData <- countData[as.vector(rowSums(unname(countData)))>0,]

#Metadata: specify the conditions of your experiments (which experiment belongs to which condition, wt or TERT)
colData <- data.frame(c("LSC_wt1", "LSC_wt2", "LSC_ouyang_1", "LSC_ouyang_2", "LSC_foxpaper_1", "LSC_foxpaper_2", "LSC_TERT1", "LSC_TERT2","LSC_TERT3","LSC_TERT4"), c("wt", "wt","wt","wt", "wt", "wt", "TERT", "TERT","TERT","TERT"))
colnames(colData) <- c("experiment", "conditions")

#DESeq2, design is the metadata (from the colData) you want to compare. It will also make a plot of the dispersion estimates and the fitting.
dds <- DESeqDataSetFromMatrix(countData = countData, colData = colData , design = ~ conditions)
dds <- DESeq(dds)
resultsNames(dds)
plotDispEsts(dds)

#Store your results
res <- results(dds)
result_wt_vs_TERT_all <- as.data.frame(res)
#Here, I invert the log2FoldChange to represent changes of TERT compared to wt and not the other way around
result_wt_vs_TERT_all$log2FoldChange <- -result_wt_vs_TERT_all$log2FoldChange

#Store the DESeq2 result as a .tsv
write.table(result_wt_vs_TERT_all, file = paste0(resultsdir,'/wt_vs_TERT_LSC_DESeq2.v2.tsv'), sep= "\t", row.names=TRUE, col.names =TRUE)

#Combine the count table and the differential gene analysis from DESeq2
result_wt_vs_TERT_all$Gene.name <- rownames(result_wt_vs_TERT_all)
joined_results <- inner_join(cts, result_wt_vs_TERT_all, by="Gene.name")

#Remove the Gene.name column and set gene names as row names
rownames(joined_results) <- joined_results[,1]
joined_results <- subset(joined_results, select = -c(1))

#Create a column of the absolute log2 Fold Change for easy filtering and selecting
joined_results$abslog2FoldChange <- abs(joined_results$log2FoldChange)

#Z-score calculation (vst normalisation) of the results from the DESeq2 object
vst_dds <- vst(dds)
vsd <- assay(vst_dds)
#Scale the rows of the resulting object
z <- t(scale(t(vsd)))
#Name the resulting columns and add these to the results table
colnames(z) <- c("z_LSC_1","z_LSC_2", "z_LSC_ouyang_1","z_LSC_ouyang_2", "z_LSC_foxpaper_1", "z_LSC_foxpaper_2", "z_LSC_TERT1", "z_LSC_TERT2","z_LSC_TERT3" ,"z_LSC_TERT4")
joined_results <- cbind(joined_results,z)
joined_results$gene.name <- rownames(joined_results)

##TPM normalisation
#Import a .tsv document containing gene names and their exonic length
gene_lengths <- read.csv("/scratch/szande_jarts/data/idgl.tsv", header = TRUE, sep= "\t")

#Remove NA values and add some additional genes and their exonic lengths
gene_lengths <- na.omit(gene_lengths)
addition <- data.frame(c("TP63", "FLG","PAX6","KRT14","LORICRIN","TGM1"), c(7479,12793,20639,2255,1245,3735))
colnames(addition) <- c("Gene.name", "Length")
gene_lengths <- rbind(gene_lengths, addition)

#Group all results of a gene together and take the minimum length for each gene
gene_lengths_new <- gene_lengths %>%
  group_by(Gene.name) %>% 
  summarise(MinLength = min(Length))

#Merge gene lengths to the count matrix and remove gene names
TPM <- merge(cts, gene_lengths_new)
rownames(TPM) <- TPM[,1]
TPM <- TPM[,2:12]

#Calculate the RPK as follows: count/gene length
TPM[,1:10] = TPM[,1:10]/TPM[,11]
#If counts are zero, this calculation will give NA values and errors later on. Replace NA values by 0.
TPM[is.na(TPM)] <- 0
#Calculate the "per million" scaling factor by summing up all counts in a sample and dividing by a million (10⁶)
rowsums <- c((colSums(TPM[,c(1:10)]))/1000000)
#Divide the RPK values by the scaling factor to obtain TPM values
TPM <- sweep(TPM[,1:10], 2, rowsums, FUN= "/")
#Add back the gene names as a column for easy searching
TPM2 <- TPM
TPM2$gene <- rownames(TPM)

##Preparing data for volcano plot
#Creating a label saying if a gene is differentially expressed
joined_results$diffexpressed <- "No change"
# if log2FoldChange > 1 and padj < 0.05, set the label as "UP" 
joined_results$diffexpressed[joined_results$log2FoldChange > 1 & joined_results$padj < 0.05] <- "Up"
# if log2FoldChange < -1 and padj < 0.05, set the label as "DOWN"
joined_results$diffexpressed[joined_results$log2FoldChange < -1 & joined_results$padj < 0.05] <- "Down"
#This creates a label for each gene, saying if it is upregulated, downregulated or if no significant change occurs

#Create the colors for the volcano plot by assigning each label to a color
ggplotcolors <- c("blue", "red", "gray")
names(ggplotcolors) <- c("Down", "Up", "No change")

#Assigning labels (gene names) to the top 6 differential and top 5 significant genes
#First, we create a new label for this
joined_results$label <- NA
#Assigning a label containing the gene name to the top 6 genes with the highest abslog2FC
joined_results <- joined_results[order(joined_results$log2FoldChange),]
joined_results$label[c(1:3,25786:25788)] <- joined_results$gene.name[c(1:3,25786:25788)]
#Assigning a label containing the gene name to the top 5 genes with the lowest padj
joined_results <- joined_results[order(joined_results$padj),]
joined_results$label[c(1:5)] <- joined_results$gene.name[c(1:5)]
#If the gene is not differentially expressed, then remove the label, as we do not want labels in the grey area of our volcano plot
joined_results$label[joined_results$diffexpressed == "No change"] <- NA

#Generate a volcano plot indicating significant genes
volcano <- ggplot(joined_results, aes(x=log2FoldChange, y=-log10(padj), col=diffexpressed, label=label)) + geom_point() + ggtitle("Volcano plot of N/TERT compared to wildtype of LSC") + geom_vline(xintercept=c(-2, 2), col="black") +
        geom_hline(yintercept=-log10(0.05), col="black") + scale_colour_manual(values = ggplotcolors) + geom_text_repel(box.padding=0.5)
volcano

#Filtering steps: padj<0.05 and remove rows with NA values in their padj
result_wt_vs_TERT_padj <- joined_results[joined_results$padj<0.05,]
result_wt_vs_TERT_padj <- result_wt_vs_TERT_padj[!is.na(result_wt_vs_TERT_padj$padj),]

#Export the genes that are differentially expressed with a padj<0.05, in descending order of log2FoldChange
genes <- result_wt_vs_TERT_padj[order(-result_wt_vs_TERT_padj[,12]),]
genes <- c(row.names(genes))
#Remove any unnecessary spacing between the gene names in the vector to avoid errors
genes <- gsub(" ", "", genes) 
write.table(genes, file = paste0(resultsdir,'/wt_vs_TERT_LSC_genes.v2.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Extract the z-scores for the genes with a padj<0.05 and order based on the z-score of LSC_1
z_padj <- as.data.frame(c(result_wt_vs_TERT_padj[18:27]))
rownames(z_padj) <- row.names(result_wt_vs_TERT_padj)
z_padj <- data.matrix(z_padj, rownames.force = NA)
z_padj <- z_padj[order(z_padj[,1]),]

# Clustering (binary data) for UpSet plot by calculating the average z-scores in wt and TERT conditions
z_padj_binary <- as.data.frame(z_padj)
z_padj_binary$average_wt <- (rowSums(z_padj[,1:6]))/2
z_padj_binary$average_TERT <- (rowSums(z_padj[,7:10]))/2
# if the average wt > 0, set as "1" 
z_padj_binary$average_wt[z_padj_binary$average_wt > 0 ] <- 1
# if the average wt < 0, set as "0" 
z_padj_binary$average_wt[z_padj_binary$average_wt < 0 ] <- 0
# repeat for the TERT average
z_padj_binary$average_TERT[z_padj_binary$average_TERT > 0 ] <- 1
z_padj_binary$average_TERT[z_padj_binary$average_TERT < 0 ] <- 0

#Plot the UpSet plot
upset(z_padj_binary)

##Heatmapping of padj<0.05 genes
#Define the colors of the heatmap
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))
#Label the 10 genes with the highest/lowest LSC_1 z-score
anno_padj = anno_mark(at = c(1:10, 7157:7166), labels = rownames(z_padj[c(1:10 , 7157:7166),]), which = "row")
#Make the heatmap using the previously specified colors and labels
htpadj <- Heatmap(z_padj, name="z-score", column_title = "Heatmap of significant genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_padj)

#I see two clusters in the padj-filtered heatmap, namely genes upregulated in TERT and genes downregulated in TERT. Therefore, I separate the heatmap based on km=2.
htpadj_cluster <- Heatmap(z_padj, km=2,  name="z-score", column_title = "Heatmap of significant genes", col = f4,  row_names_gp = gpar(fontsize = 5))
htpadj_cluster <- draw(htpadj_cluster)
#To know the order of the genes in the heatmap, I extract the row order of the heatmap
genes_htpadj <- row_order(htpadj_cluster)
#Then, I assign the genes based on their respective cluster in the heatmap. The numbers have to be adapted if a different km is used or the clusters are numbered the other way around.
genes_TERT_high <- genes_htpadj[[1]]
genes_TERT_high <- rownames(z_padj)[genes_TERT_high]
genes_TERT_low <- genes_htpadj[[2]]
genes_TERT_low <- rownames(z_padj)[genes_TERT_low]

#Filter the padj filtered dataset based on log2FoldChange>1
result_wt_vs_TERT_logfilter <- result_wt_vs_TERT_padj[result_wt_vs_TERT_padj$abslog2FoldChange > 1,]

#Again, obtain z-scores for the genes that meet these criteria
z_logfilter <- as.data.frame(c(result_wt_vs_TERT_logfilter[18:27]))
rownames(z_logfilter) <- row.names(result_wt_vs_TERT_logfilter)
z_logfilter <- data.matrix(z_logfilter, rownames.force = NA)
z_logfilter <- z_logfilter[order(z_logfilter[,1]),]

##Heatmapping of padj<0.05 & log2FC filtered genes
#Define the colors of the heatmap
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))
#Make labels for genes with highest/lowest LSC_1 z-scores
anno_logfilter = anno_mark(at = c(1:10, 6277:6286), labels = rownames(z_logfilter[c(1:10 , 6277:6286),]), which = "row")
#Make the heatmap using the previously specified colors and labels
htlog <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant differentially expressed genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark= anno_logfilter)

#Export the list of log2>1 and padj<0.05 genes ordered on descending log2FC
genes_2 <- result_wt_vs_TERT_logfilter[order(-result_wt_vs_TERT_logfilter[,12]),]
genes_2 <- c(row.names(genes_2))
#Remove unnessecary spacing
genes_2 <- gsub(" ", "", genes_2) 
write.table(genes_2, file = paste0(resultsdir,'/wt_vs_TERT_LSC_genes_2.v2.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Find the clusters of differential genes up/downregulated in TERT as done before
htlog_cluster <- Heatmap(z_logfilter, km=2 ,show_row_names = FALSE , name="z-score", column_title = "Heatmap of differential significant genes", col = f4,  row_names_gp = gpar(fontsize = 5))
htlog_cluster <- draw(htlog_cluster)
genes_htlog <- row_order(htlog_cluster)
genes_TERT_high_log <- genes_htlog[[1]]
genes_TERT_high_log <- rownames(z_logfilter)[genes_TERT_high_log]
genes_TERT_low_log <- genes_htlog[[2]]
genes_TERT_low_log <- rownames(z_logfilter)[genes_TERT_low_log]

##Find specified genes of interest in your heatmap
find_LSC <- c("EHF","PAX6" ,"TP63", "MEIS1", "FOXC1", "OTX1", "PITX1","PITX2")

#specify in what dataset you want to find these genes, in this case z_logfilter
find_LSC_row <- which(rownames(z_logfilter)%in% find_LSC, arr.ind = TRUE)

#Specify the labels for these genes
anno_lsc = anno_mark(at = find_LSC_row, labels = find_LSC , which = "row")
#Make the heatmap. The genes are not in the correct order yet since the heatmap does not have the same order as the vector of gene names.
HTlsc <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant differential genes indicating important LSC genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_lsc)
#Because of the incorrect order, we have to reorder z_logfilter based on the order of rows in the heatmap
row_order(HTlsc)
z_logfilter <- z_logfilter[row_order(HTlsc),]
#Then, we can find back the genes in the correct order, make the labels, and specify the heatmap
find_LSC <- find_LSC[order(match(find_LSC,rownames(z_logfilter)))]
find_LSC_row <- which(rownames(z_logfilter)%in% find_LSC, arr.ind = TRUE)
anno_lsc = anno_mark(at = find_LSC_row, labels = find_LSC , which = "row")
HTlsc <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant differential genes indicating important LSC genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_lsc)
draw(HTlsc)

#We now want to find the TPM values for all these genes. 
find_LSC <- c("EHF","PAX6" ,"TP63", "MEIS1", "FOXC1", "OTX1", "PITX1","PITX2")
condition_vector = c("LSC_wt1", "LSC_wt2", "LSC_ouyang_1", "LSC_ouyang_2", "LSC_foxpaper_1", "LSC_foxpaper_2", "LSC_TERT1", "LSC_TERT2","LSC_TERT3","LSC_TERT4")
find_set_LSC <- NULL

#I specify a loop: for every gene in the find_LSC vector, it finds the TPM values, names of the samples, name of the gene, and the padj value.
#It then combines these for every gene into a dataframe, and the factor function ensures the samples are plotted in the correct order.
for (xx in unique(find_LSC)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  #This line below ensures the loop does not stop if the TPM values for a gene cannot be found, but instead moves on to the next gene in the vector.
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  #Function to find the padj value for each gene
  padj <- subset(joined_results, rownames(joined_results) %in% xx)
  padj <- padj$padj
  #Make the dataframe holding the information for a single gene
  df <- data.frame(TPM=val3, condition = colnames(val),gene=xx, padj = padj)
  #This dataframe will hold the requested data for all genes
  find_set_LSC <- rbind(find_set_LSC, df)
  #This bit of code below ensures that the TPMs are plotted in the order of the condition vector
  find_set_LSC$condition = factor(find_set_LSC$condition, condition_vector)
}
#Now, we can plot the gene TPMs.
#Significance bars are manually added to the significant genes. You have to specify these yourself (sorry :)). 
#y_position indicates the height of the significance bar, xmin defines the starting x-coordinate of the bar, xmax defines the end coordinate of the bar, annotation sets the label you want to use, and tip_length sets the lengths of the vertical tips of the bar.
p_marker_LSC <- ggplot(find_set_LSC, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
     stat="identity",  position = position_dodge(0.8),
    width = 0.7) + geom_signif(y_position = c(2.0,1.5, 2.0, 2.0), xmin = c(1.6,3.6,4.6,5.6), 
xmax = c(2.4,4.4,5.4,6.4), annotation = c("*","*","*","*"),
tip_length = 0.02)

#If I want to plot the gene TPMs separately as line graphs, I first specify a line graph for every gene investigated. An asterisk is added as a label if the padj<0.05 (label=).
p1 <- ggplot(find_set_LSC[1:8,], aes(x = condition, y = TPM, group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0) + geom_point()+expand_limits(y = 0)+ geom_line(color = "blue") + ggtitle ("EHF") + scale_x_discrete(labels = c("LSC_wt1" = "LSC 1", "LSC_wt2" =  "LSC 2", "LSC_ouyang_1" = "LSC 3", "LSC_ouyang_2" = "LSC 4", "LSC_foxpaper_1"="LSC 5","LSC_foxpaper_2"="LSC 6", "LSC_TERT1"="LSC TERT 1", "LSC_TERT2"= "LSC TERT 2") )
p2 <- ggplot(find_set_LSC[9:16,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_text(vjust = 0) + geom_point() +expand_limits(y = 0)+ geom_line(color = "red") + ggtitle("PAX6")+scale_x_discrete(labels = c("LSC_wt1" = "LSC 1", "LSC_wt2" =  "LSC 2", "LSC_ouyang_1" = "LSC 3", "LSC_ouyang_2" = "LSC 4", "LSC_foxpaper_1"="LSC 5","LSC_foxpaper_2"="LSC 6", "LSC_TERT1"="LSC TERT 1", "LSC_TERT2"= "LSC TERT 2") )
p3 <- ggplot(find_set_LSC[17:24,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA)))+ geom_text(vjust = 0) + geom_point() +expand_limits(y = 0)+ geom_line(color = "green") + ggtitle("TP63")+scale_x_discrete(labels = c("LSC_wt1" = "LSC 1", "LSC_wt2" =  "LSC 2", "LSC_ouyang_1" = "LSC 3", "LSC_ouyang_2" = "LSC 4", "LSC_foxpaper_1"="LSC 5","LSC_foxpaper_2"="LSC 6", "LSC_TERT1"="LSC TERT 1", "LSC_TERT2"= "LSC TERT 2") )
p4 <- ggplot(find_set_LSC[25:32,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA)))+ geom_text(vjust = 0) + geom_point() +expand_limits(y = 0)+ geom_line(color = "yellow") + ggtitle("MEIS1")+scale_x_discrete(labels = c("LSC_wt1" = "LSC 1", "LSC_wt2" =  "LSC 2", "LSC_ouyang_1" = "LSC 3", "LSC_ouyang_2" = "LSC 4", "LSC_foxpaper_1"="LSC 5","LSC_foxpaper_2"="LSC 6", "LSC_TERT1"="LSC TERT 1", "LSC_TERT2"= "LSC TERT 2") )
p5 <- ggplot(find_set_LSC[33:40,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_point()+expand_limits(y = 0)+ geom_text(vjust = 0)+ geom_line(color = "orange") + ggtitle("FOXC1")+scale_x_discrete(labels = c("LSC_wt1" = "LSC 1", "LSC_wt2" =  "LSC 2", "LSC_ouyang_1" = "LSC 3", "LSC_ouyang_2" = "LSC 4", "LSC_foxpaper_1"="LSC 5","LSC_foxpaper_2"="LSC 6", "LSC_TERT1"="LSC TERT 1", "LSC_TERT2"= "LSC TERT 2") )
p6 <- ggplot(find_set_LSC[41:48,], aes(x = condition, y = TPM,  group = 1, label = ifelse(padj < 0.05, "*", NA))) + geom_point()+expand_limits(y = 0)+ geom_text(vjust = 0)+ geom_line(color = "purple") + ggtitle("OTX1")+scale_x_discrete(labels = c("LSC_wt1" = "LSC 1", "LSC_wt2" =  "LSC 2", "LSC_ouyang_1" = "LSC 3", "LSC_ouyang_2" = "LSC 4", "LSC_foxpaper_1"="LSC 5","LSC_foxpaper_2"="LSC 6", "LSC_TERT1"="LSC TERT 1", "LSC_TERT2"= "LSC TERT 2") )
#I now combine the line graphs in one overview
plot_LSC <- plot_grid(p1,p2,p3,p4,p5,p6)

#And I make a pdf of the result
pdf(paste(resultsdir,'LSC_marker_TPM.v2.pdf',sep="/") ,width=6,height=7,paper='special')
draw(HTlsc)
p_marker_LSC
plot_LSC
dev.off()

#I do the same for cell cycle genes as I did for important LSC markers above
cellcycle <- c("PCNA", "TOP2A", "MCM6", "MKI67", "CCND1", "CDK2", "GMNN", "AURKA", "AURKB")
find_set_cell <- NULL

for (xx in unique(cellcycle)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_cell <- rbind(find_set_cell, df)
  find_set_cell$condition = factor(find_set_cell$condition, condition_vector)
}

p_cell_LSC <- ggplot(find_set_cell, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + geom_signif(y_position = c(2.1, 3.3), xmin = c(0.6,8.6), 
                            xmax = c(1.4, 9.4), annotation = c("*","*"),
                            tip_length = 0.02) 

#Heatmapping the cell cycle genes
find_cell_row <- which(rownames(z_logfilter)%in% cellcycle, arr.ind = TRUE)
anno_cell = anno_mark(at = find_cell_row, labels = cellcycle , which = "row")
HTcell <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cell)
row_order(HTcell)
z_logfilter <- z_logfilter[row_order(HTcell),]
cellcycle <- cellcycle[order(match(cellcycle,rownames(z_logfilter)))]
find_cell_row <- which(rownames(z_logfilter)%in% cellcycle, arr.ind = TRUE)
anno_cell = anno_mark(at = find_cell_row, labels = cellcycle , which = "row")
HTcell_LSC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cell)

pdf(paste(resultsdir,'LSC_cellcycle.v2.pdf',sep="/") ,width=6,height=7,paper='special')
draw(HTcell_LSC)
p_cell_LSC
dev.off()
#-------------------------------------------------------------------------------------------

#I now perform gene ontology enrichment analysis (ORA) for several of the gene clusters I defined above. I use the clusterProfiler package for this.
#It looks up all associated biological process (BP) terms for each gene in the vector and does statistical analysis on this. 
#I only include results with an adjusted p value (q value) of <0.05.

#First, for all genes with a padj<0.05
ego <- enrichGO(gene         = genes,
                OrgDb         = org.Hs.eg.db,
                keyType       = 'SYMBOL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.05,
                readable      = FALSE)

#Then, for genes with a padj <0.05 and an abslog2FC >1
ego_2 <- enrichGO(gene         = genes_2,
                  OrgDb         = org.Hs.eg.db,
                  keyType       = 'SYMBOL',
                  ont           = "BP",
                  pAdjustMethod = "BH",
                  pvalueCutoff  = 1,
                  qvalueCutoff  = 0.05,
                  readable      = FALSE)

#I plot both results in barplots
barplot(ego, showCategory=15, title = "Barplot for padj genes")

barplot(ego_2, showCategory=15, title = "Barplot for log2 genes") 

#Merging go terms based on p values, this is to combine similar terms
ego_new <- simplify(ego, cutoff = 0.7, by = "p.adjust", select_fun = min)
ego_new_2 <- simplify(ego_2, cutoff = 0.7, by = "p.adjust", select_fun = min)

#Again, I plot the results
barplot(ego_new, showCategory=15, title = "Simplified barplot for padj genes")

barplot(ego_new_2, showCategory=15, title = "Simplified barplot for log2 genes")

#Now, I analyse the differentially expressed genes separately based on up- or downregulation in TERT LSCs
#Genes differentially upregulated in TERT
ego_high_log <- enrichGO(gene         = genes_TERT_high_log,
                  OrgDb         = org.Hs.eg.db,
                  keyType       = 'SYMBOL',
                  ont           = "BP",
                  pAdjustMethod = "BH",
                  pvalueCutoff  = 1,
                  qvalueCutoff  = 0.05,
                  readable      = FALSE)

#Genes differentially downregulated in TERT
ego_low_log <- enrichGO(gene         = genes_TERT_low_log,
                         OrgDb         = org.Hs.eg.db,
                         keyType       = 'SYMBOL',
                         ont           = "BP",
                         pAdjustMethod = "BH",
                         pvalueCutoff  = 1,
                         qvalueCutoff  = 0.05,
                         readable      = FALSE)

#Plot the result
high_log2_GO_LSC <- barplot(ego_high_log, showCategory = 15, title = "Differentially upregulated genes in TERT")
low_log2_GO_LSC <- barplot(ego_low_log, showCategory = 15, title = "Differentially downregulated genes in TERT")
high_log2_GO_LSC
low_log2_GO_LSC

#---------------------------------------------------------------------------------------------

##Finding genes associated with certain GO terms
#First, I extract the genes separated by their GO terms
go_genes <- data.matrix(ego_low_log@result$geneID)
#Then, i couple the GO terms to the gene sets
go_pathways <- data.matrix(ego_low_log@result$Description)
row.names(go_genes) <- go_pathways[,1]

#I can now extract all genes associated with a certain term, such as "epidermis development"
epi_genes <- go_genes[c("epidermis development"),]
#Remove any slashes that might be in the vector
epi_genes <- strsplit(epi_genes, split = "/")
#This creates a list, convert to a vector
epi_genes <- epi_genes[[1]]
#Remove any unnecessary spaces, which can cause errors with other functions if left untreated
epi_genes <- gsub(" ", "", epi_genes)
#Export the genes associated wih this GO term
write.table(epi_genes, file = paste0(resultsdir,'/wt_vs_TERT_LSC_epidermis_development_genes.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Here, I do the same for a different GO term, in this case "skin development
epi_diff_genes <- go_genes[c("skin development"),]
epi_diff_genes <- strsplit(epi_diff_genes, split = "/")
epi_diff_genes <- epi_diff_genes[[1]]
epi_diff_genes <- gsub(" ", "", epi_diff_genes)
write.table(epi_diff_genes, file = paste0(resultsdir,'/wt_vs_TERT_LSC_skin_development_genes.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

##Plotting the two GO gene types in the heatmap of differential genes (padj and log2FC filtered)
#Designing the color scheme
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))

#specify in what dataset you want to find these genes (z_logfilter)
epi_rows <- which(rownames(z_logfilter)%in% epi_genes, arr.ind = TRUE)

#Add labels and ensure that they are at the correct position, as done for earlier heatmaps
anno_epi = anno_mark(at = epi_rows, labels = epi_genes , which = "row")
HTep <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in epidermis development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
row_order(HTep)
z_logfilter <- z_logfilter[row_order(HTep),]
epi_genes <- epi_genes[order(match(epi_genes,rownames(z_logfilter)))]
epi_rows <- which(rownames(z_logfilter)%in% epi_genes, arr.ind = TRUE)
anno_epi = anno_mark(at = epi_rows, labels = epi_genes , which = "row")
HTep <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in epidermis development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
print(HTep)

#I now do the exact same for the second GO term
epi_diff_rows <- which(rownames(z_logfilter)%in% epi_diff_genes, arr.ind = TRUE)

#heatmapping
anno_epi_diff = anno_mark(at = epi_diff_rows, labels = epi_diff_genes , which = "row")
HTepdiff <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in skin development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_diff)
row_order(HTepdiff)
z_logfilter <- z_logfilter[row_order(HTepdiff),]
epi_diff_genes <- epi_diff_genes[order(match(epi_diff_genes,rownames(z_logfilter)))]
epi_diff_rows <- which(rownames(z_logfilter)%in% epi_diff_genes, arr.ind = TRUE)
anno_epi_diff = anno_mark(at = epi_diff_rows, labels = epi_diff_genes , which = "row")
HTepdiff <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in skin development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_diff)
print(HTepdiff)

#Plot the two heatmaps at the same time
HTep+HTepdiff
#------------------------------------------------------------------------------------------------

##KEGG analysis of differential genes
#Extract the log2FoldChange of the differential genes
log2FoldChange <- as.data.frame(result_wt_vs_TERT_padj$log2FoldChange)
#Couple the log2FC to the gene name and add column names
rownames(log2FoldChange) <- rownames(result_wt_vs_TERT_padj)
colnames(log2FoldChange) <- "log2FoldChange"
#Specify which KEGG pathways you want to investigate
pathways <- c("hsa04210", "hsa04010", "hsa04115" , "hsa04014", "hsa04064","hsa04668","hsa04151","hsa04015", "hsa04310", "hsa04330")

#This is a loop that does KEGG pathway analysis on the differential genes for each pathway in the pathways vector. The result is an image that is exported to your working directory.
for (kegg in pathways)
  { pathview(gene.data = log2FoldChange, pathway.id = kegg,
             species = "hsa", gene.idtype = "SYMBOL", out.suffix = "lsc.padj",limit = c(-2, 2), low = list(gene = "red", cpd = "blue"), mid =
               list(gene = "gray", cpd = "gray"), high = list(gene = "green", cpd =
                                                                "yellow"),)} 
# hsa04210 = apoptosis
# hsa04010 = MAPK
# hsa04115 = p53
# hsa04014 = Ras
# hsa04064 = NF-kB
# hsa04668 = TNF
# hsa04151 = PI3K
# hsa04015 = Rap1
# hsa04310 = Wnt
# hsa04330 = Notch

#Deleting leftover KEGG files that we do not need for analysis
#If you want to delete everything: unlink("hsa*")
unlink("hsa*.xml")
unlink("hsa04210.png")
unlink("hsa04010.png")
unlink("hsa04115.png")
unlink("hsa04014.png")
unlink("hsa04064.png")
unlink("hsa04668.png")
unlink("hsa04151.png")
unlink("hsa04015.png")
unlink("hsa04310.png")
unlink("hsa04330.png")


#These are additional KEGG pathway analyses for splicing and pluripotency
kegg_checks <- c("hsa03040", "hsa04550")
for (kegg in kegg_checks)
{ pathview(gene.data = log2FoldChange, pathway.id = kegg,
         species = "hsa", gene.idtype = "SYMBOL", out.suffix = "lsc.padj", limit = c(-2, 2), low = list(gene = "red", cpd = "blue"), mid =
           list(gene = "gray", cpd = "gray"), high = list(gene = "green", cpd =
                                                            "yellow"),)} 
unlink("hsa*.xml")
unlink("hsa03040.png")
unlink("hsa04550.png")

#---------------------------------------------------------------------------------------------------

#Since DNA replication seems increased in TERT cells, I manually investigate if a specified set of replication genes is differentially expressed using the same techniques used before.
find_LSC_fork <- c("TIPIN" , "CLSPN", "WDHD1", "CDC45")
find_set_fork <- NULL

for (xx in unique(find_LSC_fork)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_fork <- rbind(find_set_fork, df)
  find_set_fork$condition = factor(find_set_fork$condition, condition_vector)
}

find_set_fork_LSC <- ggplot(find_set_fork, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7)  + geom_signif(y_position = c(1.0,1.5), xmin = c(2.6,3.6), 
                                xmax = c(3.4,4.4), annotation = c("*","*"),
                                tip_length = 0.02)

find_set_fork_LSC

#Design a heatmap containing both cell cycle and replication fork genes
find_cell_fork <- c(find_LSC_fork, cellcycle)
find_cellfork_row <- which(rownames(z_logfilter)%in% find_cell_fork, arr.ind = TRUE)
anno_cellfork = anno_mark(at = find_cellfork_row, labels = find_cell_fork, which = "row")
HTcellfork <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle and replication fork genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cellfork)
row_order(HTcellfork)
z_logfilter <- z_logfilter[row_order(HTcellfork),]
find_cell_fork <- find_cell_fork[order(match(find_cell_fork,rownames(z_logfilter)))]
find_cellfork_row <- which(rownames(z_logfilter)%in% find_cell_fork, arr.ind = TRUE)
anno_cellfork = anno_mark(at = find_cellfork_row, labels = find_cell_fork, which = "row", labels_gp = gpar(fontsize = 18))
HTcellfork_LSC <- Heatmap(z_logfilter, name="z-score",  
                          col = f4,   column_names_gp = gpar(fontsize = 20),  heatmap_legend_param = list(labels_gp = gpar(fontsize = 20), title_gp = gpar(fontsize = 24))) + rowAnnotation(mark = anno_cellfork)
draw(HTcellfork_LSC)

#Add the TPM graph
find_cellfork_LSC <- NULL

for (xx in unique(find_cell_fork)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_cellfork_LSC <- rbind(find_cellfork_LSC, df)
  find_cellfork_LSC$condition = factor(find_cellfork_LSC$condition, condition_vector)
}

find_cell_fork_LSC <- ggplot(find_cellfork_LSC, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7)  + geom_signif(y_position = c(2.1,1.0,3.4,1.5), xmin = c(0.6,10.6,11.6,12.6), 
                                xmax = c(1.4,11.4,12.4,13.4), annotation = c("*","*", "*", "*"),
                                tip_length = 0.02)

#Finding back E2F1 targets in the log filtered heatmap according to previous procedures
find_e2f1_all <- c("E2F1", "DHFR", "TK1", "CCNE1",  "RB1", "TFDP1", "RBL", "MYBL2", "CDC6", "ORC1", "CDC2", "CCND1", "TYMS")

find_e2f1_row <- which(rownames(z_logfilter)%in% find_e2f1_all, arr.ind = TRUE)
anno_e2f1 = anno_mark(at = find_e2f1_row, labels = find_e2f1_all , which = "row")
HTe2f1 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating E2F1 targets", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_e2f1)
row_order(HTe2f1)
z_logfilter <- z_logfilter[row_order(HTe2f1),]
find_e2f1_all <- find_e2f1_all[order(match(find_e2f1_all,rownames(z_logfilter)))]
find_e2f1_row <- which(rownames(z_logfilter)%in% find_e2f1_all, arr.ind = TRUE)
anno_e2f1 = anno_mark(at = find_e2f1_row, labels = find_e2f1_all , which = "row")
HTe2f1 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating E2F1 targets", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_e2f1)
draw(HTe2f1)

#Plotting the TPM values of  all found targets 
find_set_e2f1_all <- NULL

for (xx in unique(find_e2f1_all)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_e2f1_all <- rbind(find_set_e2f1_all, df)
  find_set_e2f1_all$condition = factor(find_set_e2f1_all$condition, condition_vector)
}
find_set_e2f1_LSC <- ggplot(find_set_e2f1_all, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + geom_signif(y_position = c(2.4), xmin = c(2.6), 
                            xmax = c(3.4), annotation = c("*"),
                            tip_length = 0.02) 
find_set_e2f1_LSC

#-----------------------------------------------------------------------------------------------------

##PCA analysis of the samples
#Create a PDF file to store the results
pdf(paste(resultsdir,'LSC_PCA.v2.pdf',sep="/") ,width=6,height=7,paper='special')

#Specifying the dataset you want to look at (object) and the metadata it contains (intgroup)
object <- vst_dds
intgroup <- c("conditions","experiment")

#Finding back individual PC scores for the genes. summary(pc) can give you the % of variance each PC explains.
rv = rowVars(assay(object)) 
select = order(rv, decreasing=TRUE)[seq_len(min(10000, length(rv)))]
pc = prcomp(t(assay(object)[select,]))
loadings = as.data.frame(pc$rotation)
aload = loadings
sweep(aload, 2, colSums(aload), "/")

#Generate a Scree plot, which visualises the % variance each PC explains The PC = paste0("PC", x:x ... might have to be adapted if your dataset generates a different number of PCs.)
var_explained_df <- data.frame(PC= paste0("PC",1:10),
                               var_explained=(pc$sdev)^2/sum((pc$sdev)^2))
var_explained_df <- var_explained_df[order(var_explained_df$var_explained,decreasing = TRUE),]
var_explained_df$PC <- factor(var_explained_df$PC, levels = var_explained_df$PC)

var_explained_df %>%
  ggplot(aes(x=PC,y=var_explained, group=1))+
  geom_point(size=4)+
  geom_line()+
  labs(title="Scree plot of PCA")

#This is a function to generate a PCA plot of your samples. It calculates PC scores for each gene and makes the PCA plot based on this.
plotPCA.dim <- function (object, intgroup = "conditions", ntop = 500, returnData = FALSE) 
{
  rv <- rowVars(assay(object))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
                                                     length(rv)))]
  pca <- prcomp(t(assay(object)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  if (!all(intgroup %in% names(colData(object)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }
  intgroup.df <- as.data.frame(colData(object)[, intgroup, drop = FALSE])
  group <- if (length(intgroup) > 1) {
    factor(apply(intgroup.df, 1, paste, collapse = " : "))
  }
  else {
    colData(object)[[intgroup]]
  }
  d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], PC3= pca$x[,3], PC4 =pca$x[,4],PC5=pca$x[,5], group = group, 
                  intgroup.df, name = dds@colData@listData[["experiment"]])
  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:3]
    return(d)
  }
  ggplot(d, aes(PC1, PC2, color = conditions, label = name)) +geom_point(size=3) + geom_label_repel(size = 7, box.padding=0.5) + xlab(paste0("PC1: ",round(var_explained_df[1,2]*100,digits = 2),"%")) + ylab(paste0("PC2: ",round(var_explained_df[2,2]*100, digits = 2),"%")) 
  #if you ever want to change which PC dimensions to look at, change the PC in the ggplot function. For example, swap out "PC2" for "PC3". This function can go up to PCA 5.
}

#Make the PCA plot based on your DESeq2 result
PCA_LSC <- plotPCA.dim(vst_dds)
PCA_LSC

#I now extract the PC1 scores for all genes
genes_PC1 <- aload[order(aload$PC1, decreasing=TRUE),]
genes_PC1 <- as.data.frame(aload$PC1)
genes_PC1$Gene <- rownames(aload)
colnames(genes_PC1) <- c("PC1", "Gene")
#I make a histogram to decide which PC1 values would be good cutoffs to decide if a gene significantly contributes to PC1
ggplot(genes_PC1, aes(x=PC1)) + geom_histogram(binwidth=0.0001)

#Good cut-off value is likely 0.012 and above and -0.015 or lower, 
#so I make two datasets: genes with large positive PC1 scores and genes with large negative PC1 scores
genes_PC1_filtered_pos <- genes_PC1[genes_PC1$PC1>=0.012,]
genes_PC1_filtered_neg <- genes_PC1[genes_PC1$PC1 <=-0.015,]

#GO analysis of the genes with significant PC1 scores separated based on positive or negative contribution
ego_PC1_pos <- enrichGO(gene         = genes_PC1_filtered_pos$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

ego_PC1_neg <- enrichGO(gene         = genes_PC1_filtered_neg$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

#Visualisation of the results
PCA_pos_LSC <- barplot(ego_PC1_pos, showCategory = 15,title = "Genes giving positive weight to PC1")
PCA_neg_LSC <- barplot(ego_PC1_neg, showCategory = 15, title = "Genes giving negative weight to PC1")

PCA_pos_LSC
PCA_neg_LSC

#I make a heatmap that shows the distance between the samples
sampleDists <- dist(t(assay(vst_dds)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

#And I close off the pdf to generate a pdf for the PCA analysis
dev.off()

#---------------------------------------------------------------------------------------------
#From the CGS database, I import a csv file containing oncogenes, tumour suppressor genes (TSG), fusion genes and information about them.
oncogenes_table <- read.csv("/scratch/szande_jarts/CGS_1705", header= TRUE, sep = ",")

#Discard any genes marked as 'fusion gene', leaving only oncogenes and TSGs
oncogenes_table <- oncogenes_table %>% separate(Role.in.Cancer, c('Role.in.Cancer.1', 'Role.in.Cancer.2',"Role.in.Cancer.3"))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl('fusion', Role.in.Cancer.1))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl("fusion", Role.in.Cancer.2))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl('fusion', Role.in.Cancer.3))

#Extract the gene names, leaving out all other information
oncogenes <- oncogenes_table$Gene.Symbol

#Map these oncogenes/suppressor genes to the heatmap of differential genes
oncogenes_row <- which(rownames(z_logfilter)%in% oncogenes, arr.ind = TRUE)
anno_onco = anno_mark(at = oncogenes_row, labels = oncogenes , which = "row")
HTonco <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating oncogenes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_onco)
row_order(HTonco)
z_logfilter <- z_logfilter[row_order(HTonco),]
oncogenes <- oncogenes[order(match(oncogenes,rownames(z_logfilter)))]
oncogenes_row <- which(rownames(z_logfilter)%in% oncogenes, arr.ind = TRUE)
anno_onco = anno_mark(at = oncogenes_row, labels = oncogenes , which = "row")
HTonco <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating oncogenes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_onco)
draw(HTonco)

#Extract oncogenes that are significant and differential (log_oncogenes)
log_oncogenes <- rownames(subset(z_logfilter, rownames(z_logfilter) %in% oncogenes))

#Couple back the differential oncogenes to their role in cancer (oncogene or TSG)
log_oncogenes_info <- subset(oncogenes_table, oncogenes_table$Gene.Symbol %in% log_oncogenes)
log_oncogenes_info <- log_oncogenes_info[,c("Gene.Symbol", "Role.in.Cancer.1","Role.in.Cancer.2","Role.in.Cancer.3")]

#Get the log2 fold change and the padj for the differential oncogenes/TSGs
log_oncogenes_info2 <- subset(joined_results, rownames(joined_results) %in% log_oncogenes)
log_oncogenes_info2 <- log_oncogenes_info2[,c("log2FoldChange", "padj")]
log_oncogenes_info2$Gene.Symbol <- rownames(log_oncogenes_info2)

#Add the log2FC and the padj to the table containing the genes and their role in cancer
log_oncogenes_info <- inner_join(log_oncogenes_info, log_oncogenes_info2, by = "Gene.Symbol")

#Plot the distribution of up/down oncogenes and TSGs
#Set a label stating the gene type: oncogene, TSG or both
#Genes are oncogenes if they are only marked as oncogenes (oncogene in column 1 and no function in column 2), the same holds for TSGs.
log_oncogenes_info$gene.type <- c("oncogene_TSG")
log_oncogenes_info$gene.type[log_oncogenes_info$Role.in.Cancer.1 == "oncogene" & is.na(log_oncogenes_info$Role.in.Cancer.2) == TRUE] <- "oncogene"
log_oncogenes_info$gene.type[log_oncogenes_info$Role.in.Cancer.1 == "TSG" & is.na(log_oncogenes_info$Role.in.Cancer.2) == TRUE] <- "TSG"

#Set a second label stating if the gene is upregulated (1) or downregulated (0) based on the log2 Fold Change being above or below 0
log_oncogenes_info$expression <- NA
log_oncogenes_info$expression[log_oncogenes_info$log2FoldChange >0 ] <- 1
log_oncogenes_info$expression[log_oncogenes_info$log2FoldChange <0 ] <- 0
log_oncogenes_binary <- log_oncogenes_info[,c("gene.type","expression")]

#Separate based on gene type (oncogene, tumor suppressor, or both)
oncogenes_binary <- dplyr::filter(log_oncogenes_binary, grepl('oncogene', gene.type))
oncogenes_binary <- oncogenes_binary$expression

oncogenes_TSG_binary <- dplyr::filter(log_oncogenes_binary, grepl("oncogene_TSG", gene.type))
oncogenes_TSG_binary <- oncogenes_TSG_binary$expression

TSG_binary <- dplyr::filter(log_oncogenes_binary, grepl('TSG', gene.type))
TSG_binary <- TSG_binary$expression

#Create a dataframe stating how many genes are up- and downregulated for each gene type (oncogenes, oncogenes + TSG, TSG)
gene.type <- c("oncogene","oncogene","oncogene_TSG","oncogene_TSG","TSG","TSG")
gene.count <- c(sum(oncogenes_binary),length(oncogenes_binary)-sum(oncogenes_binary),
                sum(oncogenes_TSG_binary),length(oncogenes_TSG_binary)-sum(oncogenes_TSG_binary),
                sum(TSG_binary),
                length(TSG_binary)-sum(TSG_binary))
gene.condition <- c("TERT upregulated","TERT downregulated","TERT upregulated","TERT downregulated","TERT upregulated","TERT downregulated")
log_oncogenes_barchart <- data.frame(x=gene.type,y=gene.count, group=gene.condition)

#Plot the result in a bar chart
onco_plot <- ggplot(log_oncogenes_barchart, aes( x=x,y=y, fill = group)) + 
  geom_bar(position="stack", stat="identity") + scale_fill_manual(values=c("darkred","darkgreen"))

#-------------------------------------------------------------------------------------------------
#Find the TPM values for a set of epithelial markers by means of the same loop as before
epithelial <- c("KRT1", "KRT3","KRT10", "KRT12","KRT13" ,
                "KRT14", "KRT15", "KRT19", "KLF4", "KLF5","KLF6","KLF7","IVL","FLG")

df_epithelial <- NULL

for (xx in unique(epithelial)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial <- rbind(df_epithelial, df)
  df_epithelial$condition = factor(df_epithelial$condition, condition_vector)
}
p_epi1_LSC <-ggplot(df_epithelial, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers") + geom_signif(y_position = c(1.1,3.1, 2.6,2.0,1.9,2.5,3.3,4.5,3.0,4.3,1.7), xmin = c(0.6,1.6,2.6,3.6,5.6,8.6,9.6,10.6,11.6,12.6,13.6), 
                                                              xmax = c(1.4,2.4, 3.4,4.4,6.4,9.4,10.4,11.4,12.4,13.4,14.4), annotation = c("*","*","*","*","*","*","*","*","*","*","*"),
                                                              tip_length = 0.02) 

#Plot the epithelial markers on the heatmap of differential genes as done before
epithelial_row <- which(rownames(z_logfilter)%in% epithelial, arr.ind = TRUE)
anno_epi = anno_mark(at =epithelial_row, labels = epithelial , which = "row")
HTepi <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
row_order(HTepi)
z_logfilter <- z_logfilter[row_order(HTepi),]
epithelial <- epithelial[order(match(epithelial,rownames(z_logfilter)))]
epithelial_row <- which(rownames(z_logfilter)%in% epithelial, arr.ind = TRUE)
anno_epi = anno_mark(at =epithelial_row, labels = epithelial , which = "row")
HTepi_LSC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)

#I do the same for a second set of LSC-related markers
epithelial_2 <- c("GPHA2", "CPVL","CXCL14", "MMP10","S100A2" ,"SOX7",
                  "SOX9", "FOXE1", "DLX4", "DMRTA2", "GATA3")

df_epithelial_2 <- NULL

for (xx in unique(epithelial_2)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial_2 <- rbind(df_epithelial_2, df)
  df_epithelial_2$condition = factor(df_epithelial_2$condition, condition_vector)
}

p_epi2_LSC <- ggplot(df_epithelial_2, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers") + geom_signif(y_position = c(0.7,0.8, 1.8, 2.4, 1.4, 2.3), xmin = c(0.6,2.6,3.6,7.6,9.6,10.6), 
                                                               xmax = c(1.4,3.4, 4.4,8.4,10.4,11.4), annotation = c("*","*","*","*","*","*"),
                                                               tip_length = 0.02) 

epithelial_2_row <- which(rownames(z_logfilter)%in% epithelial_2, arr.ind = TRUE)
anno_epi_2 = anno_mark(at =epithelial_2_row, labels = epithelial_2 , which = "row")
HTepi2 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_2)
row_order(HTepi2)
z_logfilter <- z_logfilter[row_order(HTepi2),]
epithelial_2 <- epithelial_2[order(match(epithelial_2,rownames(z_logfilter)))]
epithelial_2_row <- which(rownames(z_logfilter)%in% epithelial_2, arr.ind = TRUE)
anno_epi_2 = anno_mark(at =epithelial_2_row, labels = epithelial_2 , which = "row")
HTepi2_LSC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_2)

#I do the analysis a third time for more general epithelial transcription factors (and some LSC transcription factors)
epithelial_3 <- c("JUN","JUNB","TFAP2A","GRHL1","GRHL2", "ETS2","ELF3","SMAD3","KERA","SLC4A11", "RUNX1", "CALML3", "FOSL2")

df_epithelial_3 <- NULL

for (xx in unique(epithelial_3)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial_3 <- rbind(df_epithelial_3, df)
  df_epithelial_3$condition = factor(df_epithelial_3$condition, condition_vector)
}

p_epi3_LSC <- ggplot(df_epithelial_3, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers") + geom_signif(y_position = c(2.1,2.0,1.9,1.9,2.5), xmin = c(1.6,3.6,4.6,10.6,11.6), 
                                                              xmax = c(2.4,4.4,5.4,11.4,12.4), annotation = c("*","*","*","*","*"),
                                                              tip_length = 0.02) 

epithelial_3_row <- which(rownames(z_logfilter)%in% epithelial_3, arr.ind = TRUE)
anno_epi_3 = anno_mark(at =epithelial_3_row, labels = epithelial_3 , which = "row")
HTepi3 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_3)
row_order(HTepi3)
z_logfilter <- z_logfilter[row_order(HTepi3),]
epithelial_3 <- epithelial_3[order(match(epithelial_3,rownames(z_logfilter)))]
epithelial_3_row <- which(rownames(z_logfilter)%in% epithelial_3, arr.ind = TRUE)
anno_epi_3 = anno_mark(at =epithelial_3_row, labels = epithelial_3 , which = "row")
HTepi3_LSC <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_3)

#I export the TPM plots and heatmaps of all investigated epithelial/LSC markers
pdf(paste(resultsdir,'LSC_epithelial markers.v2.pdf',sep="/") ,width=8,height=7,paper='special')
draw(HTepi_LSC)
p_epi1_LSC 
draw(HTepi2_LSC)
p_epi2_LSC 
draw(HTepi3_LSC)
p_epi3_LSC 
dev.off()
#-----------------------------------------------------------------------------------------
#Import genes that are differentially spliced and extract the gene names as a vector
splicing_genes <- read.csv("/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/20220623/diff_splicing_genes.v2.tsv", header = TRUE, sep= "\t") #old list: 20220525
splicing_genes <- splicing_genes[,3]

#Perform a GO analysis on these genes
ego_splice <- enrichGO(gene         = splicing_genes,
                           OrgDb         = org.Hs.eg.db,
                           keyType       = 'SYMBOL',
                           ont           = "BP",
                           pAdjustMethod = "BH",
                           pvalueCutoff  = 1,
                           qvalueCutoff  = 0.05,
                           readable      = FALSE)

#Find the log2FC scores for the spliced genes and split these into upregulated and downregulated clusters based on their log2 fold change
splicing_log2 <- joined_results[rownames(joined_results) %in% splicing_genes,]
splicing_log2 <- splicing_log2[,c("log2FoldChange","gene.name")]
pos_splicing_log2 <- splicing_log2[splicing_log2$log2FoldChange >0,]
pos_splicing_log2 <- pos_splicing_log2$gene.name
neg_splicing_log2 <- splicing_log2[splicing_log2$log2FoldChange <0,]
neg_splicing_log2 <- neg_splicing_log2$gene.name

#Perform separate GO analyses on these two clusters
ego_splice_neg <- enrichGO(gene         = neg_splicing_log2,
                         OrgDb         = org.Hs.eg.db,
                         keyType       = 'SYMBOL',
                         ont           = "BP",
                         pAdjustMethod = "BH",
                         pvalueCutoff  = 1,
                         qvalueCutoff  = 0.05,
                         readable      = FALSE)

ego_splice_pos <- enrichGO(gene         = pos_splicing_log2,
                         OrgDb         = org.Hs.eg.db,
                         keyType       = 'SYMBOL',
                         ont           = "BP",
                         pAdjustMethod = "BH",
                         pvalueCutoff  = 1,
                         qvalueCutoff  = 0.05,
                         readable      = FALSE)


#And plot the results
pdf(paste(resultsdir,'GO_LSC_splice_new.pdf',sep="/") ,width=20,height=9,paper='special')
splice_pos_GO <- barplot(ego_splice_pos, showCategory = 15, title = "Differentially spliced genes (high)")
splice_neg_GO <- barplot(ego_splice_neg, showCategory = 15, title = "Differentially spliced genes (low)")
splice_pos_GO | splice_neg_GO
dev.off()

#Find the overlap between differentially spliced and differentially expressed genes in LSC.
#You can find how many genes overlap by sum(genes_2 %in% splicing_genes).
diff_splice_exp <- genes_2[genes_2 %in% splicing_genes]

#Perform a gene ontology analysis of the genes that overlap
ego_diff <- enrichGO(gene         = diff_splice_exp,
                     OrgDb         = org.Hs.eg.db,
                     keyType       = 'SYMBOL',
                     ont           = "BP",
                     pAdjustMethod = "BH",
                     pvalueCutoff  = 1,
                     qvalueCutoff  = 0.05,
                     readable      = FALSE)

#Export the genes that are differentially spliced and expressed to your results folder
write.table(diff_splice_exp, file = paste0(resultsdir,'/diff_splice_exp_new.tsv'), sep= "\t", row.names=TRUE, col.names =TRUE)

#Split the genes based on their up- or downregulation (log2 fold change)
values_diff_splice_exp <- joined_results[rownames(joined_results) %in% diff_splice_exp,]
neg_diff_splice_exp <- values_diff_splice_exp[values_diff_splice_exp$log2FoldChange <0,]
neg_diff_splice_exp <- rownames(neg_diff_splice_exp)
pos_diff_splice_exp <- values_diff_splice_exp[values_diff_splice_exp$log2FoldChange >0,]
pos_diff_splice_exp <- rownames(pos_diff_splice_exp)

#Perform separate GO analyses on these two clusters
ego_diff_neg <- enrichGO(gene         = neg_diff_splice_exp,
                     OrgDb         = org.Hs.eg.db,
                     keyType       = 'SYMBOL',
                     ont           = "BP",
                     pAdjustMethod = "BH",
                     pvalueCutoff  = 1,
                     qvalueCutoff  = 0.05,
                     readable      = FALSE)

ego_diff_pos <- enrichGO(gene         = pos_diff_splice_exp,
                     OrgDb         = org.Hs.eg.db,
                     keyType       = 'SYMBOL',
                     ont           = "BP",
                     pAdjustMethod = "BH",
                     pvalueCutoff  = 1,
                     qvalueCutoff  = 0.05,
                     readable      = FALSE)

#Again, make a pdf of the results
pdf(paste(resultsdir,'GO_LSC_splice_exp_new.pdf',sep="/") ,width=20,height=9,paper='special')
splice_diff_pos_GO <- barplot(ego_diff_pos, showCategory = 15)
splice_diff_neg_GO <- barplot(ego_diff_neg, showCategory = 15)
splice_diff_pos_GO | splice_diff_neg_GO
dev.off()

#To find genes involved in wnt signalling, I extract these from the GO terms related to genes that are differentially spliced and downregulated.
go_genes_diff <- data.matrix(ego_diff_neg@result$geneID)
#Then, i couple the GO terms to the gene sets
go_pathways_diff <- data.matrix(ego_diff_neg@result$Description)
row.names(go_genes_diff) <- go_pathways_diff[,1]

#I can now extract all genes associated with a certain term, such as "epidermis development"
wnt_genes <- go_genes_diff[c("cell-cell signaling by wnt"),]
#Remove any slashes that might be in the vector
wnt_genes <- strsplit(wnt_genes, split = "/")
#This creates a list, convert to a vector
wnt_genes <- wnt_genes[[1]]
#Remove any unnecessary spaces, which can cause errors with other functions if left untreated
wnt_genes <- gsub(" ", "", wnt_genes)
#Export the genes associated with this GO term
write.table(wnt_genes, file = paste0(resultsdir,'/wt_vs_TERT_LSC_wnt_genes.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Close off the results PDF
dev.off()

#END
``` 
