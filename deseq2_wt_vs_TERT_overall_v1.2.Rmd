
# R script for analysing raw counts
# Overall analysis

#Version 1.2: added additional LSC TERT samples and swapped scRNA KC TERT samples for bulk RNA KC TERT samples

```{r}
##Load in the required packages
#Packages for differential gene analysis and plotting
library("DESeq2")
library("tidyverse")
library("ggrepel")
library("UpSetR")
library("EDASeq")
library("ggbreak")
library("cowplot")
library("ggsignif")
library("patchwork")
#For heatmapping and making color scales
library("ComplexHeatmap")
library("circlize")
library("RColorBrewer")
library("VennDiagram")
#For gene ontology analysis/plotting
library("clusterProfiler")
library("DOSE")
library("org.Hs.eg.db")
library("AnnotationDbi")
library("enrichplot")
library("pathview")
library("biomaRt")
print("Done loading packages, proceed to analysis")

sessionInfo()

#Make a results directory for today's date
workdir <- "/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/"
dateoftoday <- gsub("-", "", as.character(Sys.Date()))
resultsdir <- paste0(workdir, dateoftoday)
system(paste("mkdir -p ", resultsdir))
setwd(resultsdir)

#Make a PDF in which the results will be
pdf(paste(resultsdir,'ALL_TERT_vs_WT.v2.pdf',sep="/") ,width=6,height=7,paper='special')

#Load in the primary counts, remove row numbers and duplicated gene names
#Keratinocytes
cts_primary_KC <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmedKC_primary.csv", header = TRUE, sep = ",")
cts_primary_KC <- subset(cts_primary_KC, select = -c(1))
cts_primary_KC <- cts_primary_KC[!duplicated(cts_primary_KC$Gene.name),]
#Limbal stem cells
cts_primary_LSC <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmedLSC_primary.csv", header = TRUE, sep = ",")
cts_primary_LSC <- subset(cts_primary_LSC, select = -c(1))
cts_primary_LSC <- cts_primary_LSC[!duplicated(cts_primary_LSC$Gene.name),]
colnames(cts_primary_LSC) <- c("Gene.name","LSC_1","LSC_2","LSC_ouyang_1","LSC_ouyang_2","LSC_foxpaper_1","LSC_foxpaper_2")

#Join these primary datasets to make a data frame of all primary samples
cts_primary <- inner_join(cts_primary_KC, cts_primary_LSC, by="Gene.name")

#Load in the TERT counts, remove row numbers, the last two datasets and duplicated gene names
#Additional samples
cts_TERT_0906 <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmed_0906_NTERT.csv", header = TRUE, sep = ";")
#Keratinocytes
cts_TERT_KC <- cts_TERT_0906[,1:3]
cts_TERT_KC <- cts_TERT_KC[!duplicated(cts_TERT_KC$Gene.name),]
colnames(cts_TERT_KC) <- c("Gene.name", "KC_TERT_1", "KC_TERT_2")
#Limbal stem cells (without the last two datasets)
cts_TERT_LSC <- read.delim("/scratch/szande_jarts/data/coupled_list_trimmedLSC_TERT.csv", header = TRUE, sep = ",")
cts_TERT_LSC <- subset(cts_TERT_LSC, select = -c(1))
cts_TERT_LSC <- subset(cts_TERT_LSC, select = -c(4:5))
colnames(cts_TERT_LSC) <- c("Gene.name", "LSC_TERT_1", "LSC_TERT_2")
cts_TERT_LSC <- cts_TERT_LSC[!duplicated(cts_TERT_LSC$Gene.name),]

#Add the additional LSC TERT datasets to the data frame containing all LSC TERT datasets
cts_TERT_LSC_0906 <- cts_TERT_0906[,c("Gene.name","LSC_TERT_1","LSC_TERT_2")]
colnames(cts_TERT_LSC_0906) <- c("Gene.name", "LSC_TERT_3", "LSC_TERT_4")
cts_TERT_LSC_0906 <- cts_TERT_LSC_0906[!duplicated(cts_TERT_LSC_0906$Gene.name),]

#Join these TERT datasets to make a data frame of all TERT samples
cts_TERT_LSC <- inner_join(cts_TERT_LSC, cts_TERT_LSC_0906, by="Gene.name")
cts_TERT <- inner_join(cts_TERT_KC, cts_TERT_LSC, by="Gene.name")

#Merging primary and TERT tables to form one count table
cts <- inner_join(cts_primary, cts_TERT, by="Gene.name")

#Make a count table data frame out of the count matrix and remove gene names
countData <- as.data.frame(cts[,-1])
rownames(countData) <- cts[,1]

#Remove rows with only zeroes in them (aka remove genes not expressed in any condition)
countData <- countData[as.vector(rowSums(unname(countData)))>0,]

#Metadata: specify the conditions of your experiments (which experiment belongs to which condition, wt or TERT)
colData <- data.frame(c(colnames(countData)), c("primary", "primary","primary","primary","primary","primary","primary","primary", "TERT","TERT", "TERT", "TERT", "TERT", "TERT"))
colnames(colData) <- c("experiment", "conditions")

#DESeq2, design is the metadata (from the colData) you want to compare. It will also make a plot of the dispersion estimates and the fitting.
dds <- DESeqDataSetFromMatrix(countData = countData, colData = colData , design = ~ conditions)
dds <- DESeq(dds)
plotDispEsts(dds)
resultsNames(dds)

#Store your results
res <- results(dds)
result_wt_vs_TERT_all <- as.data.frame(res)
#Store the DESeq2 result as a .tsv
write.table(result_wt_vs_TERT_all, file = paste0(resultsdir,'/wt_vs_TERT_all_DESeq2_v2.tsv'), sep= "\t", row.names=TRUE, col.names =TRUE)

#Combine the count table and the differential gene analysis from DESeq2
result_wt_vs_TERT_all$Gene.name <- rownames(result_wt_vs_TERT_all)
joined_results <- inner_join(cts, result_wt_vs_TERT_all, by="Gene.name")

#Remove the Gene.name column and set gene names as row names
rownames(joined_results) <- joined_results[,1]
joined_results <- subset(joined_results, select = -c(1))

#Create a column of the absolute log2 Fold Change for easy filtering and selecting
joined_results$abslog2FoldChange <- abs(joined_results$log2FoldChange)

#Z-score calculation (vst normalisation) of the results from the DESeq2 object
vst_dds <- vst(dds)
vsd <- assay(vst_dds)
#Scale the rows of the resulting object
z <- t(scale(t(vsd)))
#Name the resulting columns and add these to the results table
colnames(z) <- c("z_PKC_1","z_PKC_2","z_LSC_1","z_LSC_2","z_LSC_ouyang_1","z_LSC_ouyang_2","z_LSC_foxpaper_1","z_LSC_foxpaper_2", "z_KC_TERT_1","z_KC_TERT_2","z_LSC_TERT_1","z_LSC_TERT_2", "z_LSC_TERT_3", "z_LSC_TERT_4")
joined_results <- cbind(joined_results,z)
joined_results$gene.name <- rownames(joined_results)

#Z-score raw counts
vst_dds_new <- vst(data.matrix(cts[,2:15]))
z_new <- t(scale(t(vst_dds_new)))
colnames(z_new) <- c("z_PKC_1","z_PKC_2","z_LSC_1","z_LSC_2","z_LSC_ouyang_1","z_LSC_ouyang_2","z_LSC_foxpaper_1","z_LSC_foxpaper_2", "z_KC_TERT_1","z_KC_TERT_2","z_LSC_TERT_1","z_LSC_TERT_2", "z_LSC_TERT_3", "z_LSC_TERT_4")
rownames(z_new) <- cts[,1]

#Make a heatmap of the distance between all samples
sampleDists <- dist(t(assay(vst_dds)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

##TPM normalisation
#Import a .tsv file containing genes and their exonic lengths
gene_lengths <- read.csv("/scratch/szande_jarts/data/idgl.tsv", header = TRUE, sep= "\t")

#Remove NA values
gene_lengths <- na.omit(gene_lengths)

addition <- data.frame(c("TP63", "FLG","PAX6","KRT14","LORICRIN","TGM1"), c(7479,12793,20639,2255,1245,3735))
colnames(addition) <- c("Gene.name", "Length")
gene_lengths <- rbind(gene_lengths, addition)

#Take the minimum length for each gene
gene_lengths_new <- gene_lengths %>%
  group_by(Gene.name) %>% 
  summarise(MinLength = min(Length))

#Merge gene lengths to the count matrix and remove gene names
TPM <- merge(cts, gene_lengths_new)
rownames(TPM) <- TPM[,1]
TPM <- TPM[,2:16]

#Calculate the RPK as follows: count/gene length
TPM[,1:14] = TPM[,1:14]/TPM[,15]
#If counts are zero, this calculation will give NA values and errors later on. Replace NA values by 0.
TPM[is.na(TPM)] <- 0
#Calculate the "per million" scaling factor by summing up all counts in a sample and dividing by a million (10â¶)
rowsums <- c((colSums(TPM[,c(1:14)]))/1000000)
#Divide the RPK values by the scaling factor to obtain TPM values
TPM <- sweep(TPM[,1:14], 2, rowsums, FUN= "/")
#Add back the gene names as a column for easy searching
TPM2 <- TPM
TPM2$gene <- rownames(TPM)

##Preparing data for volcano plot
#Creating a label saying if a gene is differentially expressed
joined_results$diffexpressed <- "No change"
# if log2FoldChange > 1 and padj < 0.05, set the label as "UP" 
joined_results$diffexpressed[joined_results$log2FoldChange > 1 & joined_results$padj < 0.05] <- "Up"
# if log2FoldChange < -1 and padj < 0.05, set the label as "DOWN"
joined_results$diffexpressed[joined_results$log2FoldChange < -1 & joined_results$padj < 0.05] <- "Down"
#This creates a label for each gene, saying if it is upregulated, downregulated or if no significant change occurs

#Create the colors for the volcano plot by assigning each label to a color
ggplotcolors <- c("blue", "red", "gray")
names(ggplotcolors) <- c("Down", "Up", "No change")

#Assigning labels (gene names) to the top 6 differential and top 5 significant genes
#First, we create a new label for this
joined_results$label <- NA
#Assigning a label containing the gene name to the top 6 genes with the highest abslog2FC
joined_results <- joined_results[order(joined_results$log2FoldChange),]
joined_results$label[c(1:3, 26785:26787)] <- joined_results$gene.name[c(1:3, 26785:26787)]
#Assigning a label containing the gene name to the top 5 genes with the lowest padj
joined_results <- joined_results[order(joined_results$padj),]
joined_results$label[c(1:5)] <- joined_results$gene.name[c(1:5)]

#Generate a volcano plot indicating significant genes
volcano <-ggplot(joined_results, aes(x=log2FoldChange, y=-log10(padj), col=diffexpressed, label=label)) + geom_point() + ggtitle("Volcano plot of N/TERT compared to wildtype of all cell types") + geom_vline(xintercept=c(-1, 1), col="black") +
        geom_hline(yintercept=-log10(0.05), col="black") + scale_colour_manual(values = ggplotcolors) + geom_text_repel(box.padding=0.5, max.overlaps = Inf)
volcano

#Filtering steps: padj<0.05 and remove rows with NA values in their padj
result_wt_vs_TERT_padj <- joined_results[joined_results$padj<0.05,]
result_wt_vs_TERT_padj <- result_wt_vs_TERT_padj[!is.na(result_wt_vs_TERT_padj$padj),]

#Export the genes that are differentially expressed with a padj<0.05, in descending order of log2FoldChange
genes <- result_wt_vs_TERT_padj[order(-result_wt_vs_TERT_padj$log2FoldChange),]
genes <- c(row.names(genes))
#Remove any unnecessary spacing between the gene names in the vector to avoid errors
genes <- gsub(" ", "", genes) 
write.table(genes, file = paste0(resultsdir,'/wt_vs_TERT_all_genes_v2.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Extract the z-scores for the genes with a padj<0.05 and order based on the z-score of LSC_1
z_padj <- as.data.frame(c(result_wt_vs_TERT_padj[22:35]))
rownames(z_padj) <- row.names(result_wt_vs_TERT_padj)
z_padj <- data.matrix(z_padj, rownames.force = NA)
z_padj <- z_padj[order(z_padj[,1]),]

# Clustering (binary data) for UpSet plot by calculating the average z-scores in wt and TERT conditions
z_padj_binary <- as.data.frame(z_padj)
z_padj_binary$average_wt <- (rowSums(z_padj[,1:8]))/2
z_padj_binary$average_TERT <- (rowSums(z_padj[,9:14]))/2
# if the average wt > 0, set as "1" 
z_padj_binary$average_wt[z_padj_binary$average_wt > 0 ] <- 1
# if the average wt < 0, set as "0" 
z_padj_binary$average_wt[z_padj_binary$average_wt < 0 ] <- 0
#repeat for the TERT condition
z_padj_binary$average_TERT[z_padj_binary$average_TERT > 0 ] <- 1
z_padj_binary$average_TERT[z_padj_binary$average_TERT < 0 ] <- 0

#Plot the UpSet plot
upset(z_padj_binary)

##Heatmapping of padj<0.05 genes
#Define the colors of the heatmap
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))

#Label the 10 genes with the highest/lowest LSC_1 z-score
anno_padj = anno_mark(at = c(1:10, 7020:7029), labels = rownames(z_padj[c(1:10 , 7020:7029),]), which = "row")

#Make the heatmap using the previously specified colors and labels
htpadj <- Heatmap(z_padj, name="z-score", column_title = "Heatmap of significant genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_padj)

#I see two clusters in the padj-filtered heatmap, namely genes upregulated in TERT and genes downregulated in TERT. Therefore, I separate the heatmap based on km=2.
htpadj_cluster <- Heatmap(z_padj, km=2,  name="z-score", column_title = "Heatmap of significant genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark=anno_padj)
htpadj_cluster <- draw(htpadj_cluster)
#To know the order of the genes in the heatmap, I extract the row order of the heatmap
genes_htpadj <- row_order(htpadj_cluster)
#Then, I assign the genes based on their respective cluster in the heatmap. The numbers have to be adapted if a different km is used or the clusters are numbered the other way around.
genes_TERT_high <- genes_htpadj[[2]]
genes_TERT_high <- rownames(z_padj)[genes_TERT_high]
genes_TERT_low <- genes_htpadj[[1]]
genes_TERT_low <- rownames(z_padj)[genes_TERT_low]

#Filter the padj filtered dataset based on log2FoldChange>1
result_wt_vs_TERT_logfilter <- result_wt_vs_TERT_padj[result_wt_vs_TERT_padj$abslog2FoldChange >= 1,]

#Again, obtain z-scores for the genes that meet these criteria
z_logfilter <- as.data.frame(c(result_wt_vs_TERT_logfilter[22:35]))
rownames(z_logfilter) <- row.names(result_wt_vs_TERT_logfilter)
z_logfilter <- data.matrix(z_logfilter, rownames.force = NA)
z_logfilter <- z_logfilter[order(z_logfilter[,1]),]

##Heatmapping of padj<0.05 & log2FC filtered genes
#Define the colors of the heatmap
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))
#Make labels for genes with highest/lowest LSC_1 z-scores
anno_logfilter = anno_mark(at = c(1:10, 5633:5642), labels = rownames(z_logfilter[c(1:10 , 5633:5642),]), which = "row")
#Make the heatmap using the previously specified colors and labels
htlog <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant differentially expressed genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark= anno_logfilter)

#Export the list of log2>1 and padj<0.05 genes ordered on descending log2FC
genes_2 <- result_wt_vs_TERT_logfilter[order(-result_wt_vs_TERT_logfilter$log2FoldChange),]
genes_2 <- c(row.names(genes_2))
#Remove unnessecary spacing
genes_2 <- gsub(" ", "", genes_2) 
write.table(genes_2, file = paste0(resultsdir,'/wt_vs_TERT_all_genes_2_v2.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Find the clusters of differential genes up/downregulated in TERT as done before
htlog_cluster <- Heatmap(z_logfilter, km=2,  name="z-score", column_title = "Heatmap of differential significant genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark=anno_logfilter)
htlog_cluster <- draw(htlog_cluster)
genes_htlog <- row_order(htlog_cluster)
genes_TERT_high_log <- genes_htlog[[2]]
genes_TERT_high_log <- rownames(z_logfilter)[genes_TERT_high_log]
genes_TERT_low_log <- genes_htlog[[1]]
genes_TERT_low_log <- rownames(z_logfilter)[genes_TERT_low_log]

#Plot the genes that are differentially downregulated in hTERT cells in their own heatmap
z_logfilter_primary <- subset(z_logfilter, rownames(z_logfilter) %in% genes_TERT_low_log)

f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))
anno_logfilter_primary = anno_mark(at = c(1:5, 3318:3327), labels = rownames(z_logfilter_primary[c(1:5 , 3318:3327),]), which = "row")
htlog_primary <- Heatmap(z_logfilter_primary, name="z-score", column_title = "Heatmap of TERT-low significant differentially expressed genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark= anno_logfilter_primary)

#Plot the genes that are differentially upregulated in hTERT cells in their own heatmap
z_logfilter_TERT <- subset(z_logfilter, rownames(z_logfilter) %in% genes_TERT_high_log)

f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))
anno_logfilter_TERT = anno_mark(at = c(1:5, 2306:2315), labels = rownames(z_logfilter_TERT[c(1:5 , 2306:2315),]), which = "row")
htlog_TERT <- Heatmap(z_logfilter_TERT, km=3, name="z-score", column_title = "Heatmap of TERT-high significant differentially expressed genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark= anno_logfilter_TERT)
htlog_TERT <- draw(htlog_TERT)

#Plot the expression of differentially upregulated genes, but now only in hTERT samples.
z_logfilter_TERT_subset <- z_logfilter_TERT[,9:12]
z_logfilter_TERT_subset <- z_logfilter_TERT_subset[order(z_logfilter_TERT_subset[,4]),]
anno_logfilter_TERT_sub = anno_mark(at = c(10:15, 150:155, 274:279), labels = rownames(z_logfilter_TERT_subset[c(10:15, 150:155, 274:279),]), which = "row")
htlog_TERT_subset <- Heatmap(z_logfilter_TERT_subset, km=3, name="z-score", column_title = "Heatmap of TERT-high significant differentially expressed genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark= anno_logfilter_TERT_sub)

##Find specified genes of interest in your heatmap
find_all <- c("EHF","PAX6" ,"TP63", "MEIS1", "FOXC1", "OTX1","KRT5","KRT14" ,"IGFBP3", "MCM3", "IVL", "LORICRIN", "FLG", "TGM1")

#specify in what dataset you want to find these genes, in this case z_logfilter
find_all_row <- which(rownames(z_logfilter)%in% find_all, arr.ind = TRUE)

#Specify the labels for these genes
anno_all = anno_mark(at = find_all_row, labels = find_all , which = "row")
#Make the heatmap. The genes are not in the correct order yet since the heatmap does not have the same order as the vector of gene names.
HTall <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant genes indicating important genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_all)
#Because of the incorrect order, we have to reorder z_logfilter based on the order of rows in the heatmap
row_order(HTall)
z_logfilter <- z_logfilter[row_order(HTall),]
#Then, we can find back the genes in the correct order, make the labels, and specify the heatmap
find_all <- find_all[order(match(find_all,rownames(z_logfilter)))]
find_all_row <- which(rownames(z_logfilter)%in% find_all, arr.ind = TRUE)
anno_all = anno_mark(at = find_all_row, labels = find_all , which = "row")
HTall <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap of significant genes indicating important genes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_all)
draw(HTall)

#We now want to find the TPM values for all these genes. 
condition_vector <- c("PKC_1", "PKC_2", "LSC_1","LSC_2","LSC_ouyang_1","LSC_ouyang_2","LSC_foxpaper_1","LSC_foxpaper_2", "KC_TERT_1", "KC_TERT_2", "LSC_TERT_1","LSC_TERT_2", "LSC_TERT_3", "LSC_TERT_4")
find_set_all <- NULL

#I specify a loop: for every gene in the find_LSC vector, it finds the TPM values, names of the samples, name of the gene, and the padj value.
#It then combines these for every gene into a dataframe, and the factor function ensures the samples are plotted in the correct order.
for (xx in unique(find_all)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  #This line below ensures the loop does not stop if the TPM values for a gene cannot be found, but instead moves on to the next gene in the vector.
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  #Make the dataframe holding the information for a single gene
  df <- data.frame(TPM=val3, condition = colnames(val),gene=xx)
  #This dataframe will hold the requested data for all genes
  find_set_all <- rbind(find_set_all, df)
  #This bit of code below ensures that the TPMs are plotted in the order of the condition vector
  find_set_all$condition = factor(find_set_all$condition, condition_vector)
}

#Now, we can plot the gene TPMs.
#Significance bars are manually added to the significant genes. You have to specify these yourself (sorry). 
#y_position indicates the height of the significance bar, xmin defines the starting x-coordinate of the bar, xmax defines the end coordinate of the bar, annotation sets the label you want to use, and tip_length sets the lengths of the vertical tips of the bar.
p_marker <- ggplot(find_set_all, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
     stat="identity",  position = position_dodge(0.8),
    width = 0.7)  + geom_signif(y_position = c(3.3,5.5), xmin = c(1.6,2.6), 
                                xmax = c(2.4,3.4), annotation = c("*","*"),
                                tip_length = 0.02)


#And I make a pdf of the result
pdf(paste(resultsdir,'ALL_marker.v2.pdf',sep="/") ,width=6,height=7,paper='special')
draw(HTall)
p_marker
dev.off()

#I do the same for cell cycle genes as I did for important markers above
cellcycle <- c("PCNA", "TOP2A", "MCM6", "MKI67", "CCND1", "CDK2", "GMNN", "AURKA", "AURKB")
find_set_cell <- NULL

for (xx in unique(cellcycle)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_cell <- rbind(find_set_cell, df)
  find_set_cell$condition = factor(find_set_cell$condition, condition_vector)
}

p_cell <- ggplot(find_set_cell, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + geom_signif(y_position = c(1.7,2.7), xmin = c(3.6,4.6), 
                               xmax = c(4.4,5.4), annotation = c("*","*"),
                               tip_length = 0.02)

#Heatmapping the cell cycle genes
find_cell_row <- which(rownames(z_logfilter)%in% cellcycle, arr.ind = TRUE)
anno_cell = anno_mark(at = find_cell_row, labels = cellcycle , which = "row")
HTcell <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cell)
row_order(HTcell)
z_logfilter <- z_logfilter[row_order(HTcell),]
cellcycle <- cellcycle[order(match(cellcycle,rownames(z_logfilter)))]
find_cell_row <- which(rownames(z_logfilter)%in% cellcycle, arr.ind = TRUE)
anno_cell = anno_mark(at = find_cell_row, labels = cellcycle , which = "row")
HTcell <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating cell cycle markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_cell)

pdf(paste(resultsdir,'ALL_cellcycle.v2.pdf',sep="/") ,width=6,height=7,paper='special')
draw(HTcell)
p_cell
dev.off()
#-------------------------------------------------------------------------------------------

#I now perform gene ontology enrichment analysis (ORA) for several of the gene clusters I defined above. I use the clusterProfiler package for this.
#It looks up all associated biological process (BP) terms for each gene in the vector and does statistical analysis on this. 
#I only include results with an adjusted p value (q value) of <0.05.

#First, for all genes with a padj<0.05
ego <- enrichGO(gene         = genes,
                OrgDb         = org.Hs.eg.db,
                keyType       = 'SYMBOL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.05,
                readable      = FALSE)

#Then, for genes with a padj <0.05 and an abslog2FC >1
ego_2 <- enrichGO(gene         = genes_2,
                  OrgDb         = org.Hs.eg.db,
                  keyType       = 'SYMBOL',
                  ont           = "BP",
                  pAdjustMethod = "BH",
                  pvalueCutoff  = 1,
                  qvalueCutoff  = 0.05,
                  readable      = FALSE)

#I plot both results in barplots
barplot(ego, showCategory=15, title = "Barplot for padj genes")

barplot(ego_2, showCategory=15, title = "Barplot for log2 genes") 

#Merging go terms based on p values, this is to combine similar terms
ego_new <- simplify(ego, cutoff = 0.9, by = "p.adjust", select_fun = min)
ego_new_2 <- simplify(ego_2, cutoff = 0.9, by = "p.adjust", select_fun = min)

#Again, I plot the results
barplot(ego_new, showCategory=15, title = "Simplified barplot for padj genes")

barplot(ego_new_2, showCategory=15, title = "Simplified barplot for log2 genes")

#Now, I analyse the differentially expressed genes separately based on up- or downregulation in TERT cells
#Genes differentially upregulated in TERT
ego_high_log <- enrichGO(gene         = genes_TERT_high_log,
                     OrgDb         = org.Hs.eg.db,
                     keyType       = 'SYMBOL',
                     ont           = "BP",
                     pAdjustMethod = "BH",
                     pvalueCutoff  = 1,
                     qvalueCutoff  = 0.05,
                     readable      = FALSE)

#Genes differentially downregulated in TERT
ego_low_log <- enrichGO(gene         = genes_TERT_low_log,
                    OrgDb         = org.Hs.eg.db,
                    keyType       = 'SYMBOL',
                    ont           = "BP",
                    pAdjustMethod = "BH",
                    pvalueCutoff  = 1,
                    qvalueCutoff  = 0.05,
                    readable      = FALSE)

#Plotting of the results
high_log2_GO <- barplot(ego_high_log, showCategory = 15, title = "Differentially upregulated genes in TERT")
low_log2_GO <- barplot(ego_low_log, showCategory = 15, title = "Differentially downregulated genes in TERT")
high_log2_GO
low_log2_GO

#---------------------------------------------------------------------------------------------
##Finding genes associated with certain GO terms
#First, I extract the genes separated by their GO terms
go_genes <- data.matrix(ego_low_log@result$geneID)
#Then, i couple the GO terms to the gene sets
go_pathways <- data.matrix(ego_low_log@result$Description)
row.names(go_genes) <- go_pathways[,1]

#I can now extract all genes associated with a certain term, such as "epidermis development"
epi_genes <- go_genes[c("epidermis development"),]
#Remove any slashes that might be in the vector
epi_genes <- strsplit(epi_genes, split = "/")
#This creates a list, convert to a vector
epi_genes <- epi_genes[[1]]
#Remove any unnecessary spaces, which can cause errors with other functions if left untreated
epi_genes <- gsub(" ", "", epi_genes)
#Export the genes associated wih this GO term
write.table(epi_genes, file = paste0(resultsdir,'/wt_vs_TERT_ALL_epidermis_development_genes.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

#Here, I do the same for a different GO term, in this case "skin development
epi_diff_genes <- go_genes[c("skin development"),]
epi_diff_genes <- strsplit(epi_diff_genes, split = "/")
epi_diff_genes <- epi_diff_genes[[1]]
epi_diff_genes <- gsub(" ", "", epi_diff_genes)
write.table(epi_diff_genes, file = paste0(resultsdir,'/wt_vs_TERT_ALL_skin_development_genes.tsv'), sep= "\t", row.names=FALSE, col.names =FALSE)

##Plotting the two GO gene types in the heatmap of differential genes (padj and log2FC filtered)
#Designing the color scheme
f4 = colorRamp2(c(-1.5, 0, 1.5), c("blue", "white", "red"))

#specify in what dataset you want to find these genes (z_logfilter)
epi_rows <- which(rownames(z_logfilter)%in% epi_genes, arr.ind = TRUE)

#Add labels and ensure that they are at the correct position, as done for earlier heatmaps
anno_epi = anno_mark(at = epi_rows, labels = epi_genes , which = "row")
HTep <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in epidermis development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
row_order(HTep)
z_logfilter <- z_logfilter[row_order(HTep),]
epi_genes <- epi_genes[order(match(epi_genes,rownames(z_logfilter)))]
epi_rows <- which(rownames(z_logfilter)%in% epi_genes, arr.ind = TRUE)
anno_epi = anno_mark(at = epi_rows, labels = epi_genes , which = "row")
HTep <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in epidermis development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
print(HTep)

#I now do the exact same for the second GO term
epi_diff_rows <- which(rownames(z_logfilter)%in% epi_diff_genes, arr.ind = TRUE)

#heatmapping
anno_epi_diff = anno_mark(at = epi_diff_rows, labels = epi_diff_genes , which = "row")
HTepdiff <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in skin development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_diff)
row_order(HTepdiff)
z_logfilter <- z_logfilter[row_order(HTepdiff),]
epi_diff_genes <- epi_diff_genes[order(match(epi_diff_genes,rownames(z_logfilter)))]
epi_diff_rows <- which(rownames(z_logfilter)%in% epi_diff_genes, arr.ind = TRUE)
anno_epi_diff = anno_mark(at = epi_diff_rows, labels = epi_diff_genes , which = "row")
HTepdiff <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating genes involved in skin development", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_diff)
print(HTepdiff)

#Plot the two heatmaps at the same time
HTep+HTepdiff

#------------------------------------------------------------------------------------------------

##KEGG analysis of differential genes
#Extract the log2FoldChange of the differential genes
log2FoldChange <- as.data.frame(result_wt_vs_TERT_padj$log2FoldChange)
#Couple the log2FC to the gene name and add column names
rownames(log2FoldChange) <- rownames(result_wt_vs_TERT_padj)
colnames(log2FoldChange) <- "log2FoldChange"
#Specify which KEGG pathways you want to investigate

#This is a loop that does KEGG pathway analysis on the differential genes for each pathway in the pathways vector. The result is an image that is exported to your working directory.
pathways <- c("hsa04210", "hsa04010", "hsa04115" , "hsa04014", "hsa04064","hsa04668","hsa04151","hsa04015", "hsa04310", "hsa04330")
for (kegg in pathways)
  { pathview(gene.data = log2FoldChange, pathway.id = kegg,
             species = "hsa", gene.idtype = "SYMBOL", out.suffix = "all.padj",limit = c(-2, 2), low = list(gene = "red", cpd = "blue"), mid =
               list(gene = "gray", cpd = "gray"), high = list(gene = "green", cpd =
                                                                "yellow"),)} 
# hsa04210 = apoptosis
# hsa04010 = MAPK
# hsa04115 = p53
# hsa04014 = Ras
# hsa04064 = NF-kB
# hsa04668 = TNF
# hsa04151 = PI3K
# hsa04015 = Rap1
# hsa04310 = Wnt
# hsa04330 = Notch

#Deleting leftover KEGG files that we do not need for analysis
#If you want to delete everything: unlink("hsa*")unlink("hsa*.xml")
unlink("hsa04210.png")
unlink("hsa04010.png")
unlink("hsa04115.png")
unlink("hsa04014.png")
unlink("hsa04064.png")
unlink("hsa04668.png")
unlink("hsa04151.png")
unlink("hsa04015.png")
unlink("hsa04310.png")
unlink("hsa04330.png")

#These are additional KEGG pathway analyses for splicing and pluripotency
kegg_checks <- c("hsa03040", "hsa04550")
for (kegg in kegg_checks)
{ pathview(gene.data = log2FoldChange, pathway.id = kegg,
         species = "hsa", gene.idtype = "SYMBOL", out.suffix = "all.padj", limit = c(-2, 2), low = list(gene = "red", cpd = "blue"), mid =
           list(gene = "gray", cpd = "gray"), high = list(gene = "green", cpd =
                                                            "yellow"),)} 
unlink("hsa*.xml")
unlink("hsa03040.png")
unlink("hsa04550.png")

#---------------------------------------------------------------------------------------------------
#Since DNA replication seems increased in TERT cells, I manually investigate if a specified set of replication genes is differentially expressed using the same techniques used before.
find_fork <- c("TIPIN" , "CLSPN", "WDHD1", "CDC45")
find_set_fork <- NULL

for (xx in unique(find_fork)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_fork <- rbind(find_set_fork, df)
  find_set_fork$condition = factor(find_set_fork$condition, condition_vector)
   }
find_set_fork_ALL <- ggplot(find_set_fork, aes(x = gene, y = TPM)) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7)

find_set_fork_ALL

#Finding back E2F1 targets in the log filtered heatmap according to previous procedures
find_e2f1_all <- c("E2F1", "DHFR", "TK1", "CCNE1",  "RB1", "TFDP1", "RBL", "MYBL2", "CDC6", "ORC1", "CDC2", "CCND1", "TYMS")

find_e2f1_row <- which(rownames(z_padj)%in% find_e2f1_all, arr.ind = TRUE)
anno_e2f1 = anno_mark(at = find_e2f1_row, labels = find_e2f1_all , which = "row")
HTe2f1 <- Heatmap(z_padj, name="z-score", column_title = "Heatmap indicating E2F1 targets", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_e2f1)
row_order(HTe2f1)
z_padj <- z_padj[row_order(HTe2f1),]
find_e2f1_all <- find_e2f1_all[order(match(find_e2f1_all,rownames(z_padj)))]
find_e2f1_row <- which(rownames(z_padj)%in% find_e2f1_all, arr.ind = TRUE)
anno_e2f1 = anno_mark(at = find_e2f1_row, labels = find_e2f1_all , which = "row")
HTe2f1 <- Heatmap(z_padj, name="z-score", column_title = "Heatmap indicating E2F1 targets", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_e2f1)
draw(HTe2f1)

#Plotting the TPM values of  all found targets 
find_set_e2f1_all <- NULL

for (xx in unique(find_e2f1_all)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  find_set_e2f1_all <- rbind(find_set_e2f1_all, df)
  find_set_e2f1_all$condition = factor(find_set_e2f1_all$condition, condition_vector)
}
find_set_e2f1_ALL <- ggplot(find_set_e2f1_all, aes(x = gene, y = TPM)) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) 

find_set_e2f1_ALL

#From the CGS database, I import a csv file containing oncogenes, tumour suppressor genes (TSG), fusion genes and information about them.
oncogenes_table <- read.csv("/scratch/szande_jarts/CGS_1705", header= TRUE, sep = ",")

#Discard any genes marked as 'fusion gene', leaving only oncogenes and TSGs
oncogenes_table <- oncogenes_table %>% separate(Role.in.Cancer, c('Role.in.Cancer.1', 'Role.in.Cancer.2',"Role.in.Cancer.3"))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl('fusion', Role.in.Cancer.1))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl("fusion", Role.in.Cancer.2))
oncogenes_table <- dplyr::filter(oncogenes_table, !grepl('fusion', Role.in.Cancer.3))

#Extract the gene names, leaving out all other information
oncogenes <- oncogenes_table$Gene.Symbol

#Map these oncogenes/suppressor genes to the heatmap of differential genes
oncogenes_row <- which(rownames(z_logfilter)%in% oncogenes, arr.ind = TRUE)
anno_onco = anno_mark(at = oncogenes_row, labels = oncogenes , which = "row")
HTonco <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating oncogenes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_onco)
row_order(HTonco)
z_logfilter <- z_logfilter[row_order(HTonco),]
oncogenes <- oncogenes[order(match(oncogenes,rownames(z_logfilter)))]
oncogenes_row <- which(rownames(z_logfilter)%in% oncogenes, arr.ind = TRUE)
anno_onco = anno_mark(at = oncogenes_row, labels = oncogenes , which = "row")
HTonco <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating oncogenes", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_onco)
draw(HTonco)

#Extract oncogenes that are significant and differential (log_oncogenes)
log_oncogenes <- rownames(subset(z_logfilter, rownames(z_logfilter) %in% oncogenes))

#Couple back the differential oncogenes to their role in cancer (oncogene or TSG)
log_oncogenes_info <- subset(oncogenes_table, oncogenes_table$Gene.Symbol %in% log_oncogenes)
log_oncogenes_info <- log_oncogenes_info[,c("Gene.Symbol", "Role.in.Cancer.1","Role.in.Cancer.2","Role.in.Cancer.3")]

#Get the log2 fold change and the padj for the differential oncogenes/TSGs
log_oncogenes_info2 <- subset(joined_results, rownames(joined_results) %in% log_oncogenes)
log_oncogenes_info2 <- log_oncogenes_info2[,c("log2FoldChange", "padj")]
log_oncogenes_info2$Gene.Symbol <- rownames(log_oncogenes_info2)

#Add the log2FC and the padj to the table containing the genes and their role in cancer
log_oncogenes_info <- inner_join(log_oncogenes_info, log_oncogenes_info2, by = "Gene.Symbol")

#Plot the distribution of up/down oncogenes and TSGs
#Set a label stating the gene type: oncogene, TSG or both
#Genes are oncogenes if they are only marked as oncogenes (oncogene in column 1 and no function in column 2), the same holds for TSGs.
log_oncogenes_info$gene.type <- c("oncogene_TSG")
log_oncogenes_info$gene.type[log_oncogenes_info$Role.in.Cancer.1 == "oncogene" & is.na(log_oncogenes_info$Role.in.Cancer.2) == TRUE] <- "oncogene"
log_oncogenes_info$gene.type[log_oncogenes_info$Role.in.Cancer.1 == "TSG" & is.na(log_oncogenes_info$Role.in.Cancer.2) == TRUE] <- "TSG"

#Set a second label stating if the gene is upregulated (1) or downregulated (0) based on the log2 Fold Change being above or below 0
log_oncogenes_info$expression <- NA
log_oncogenes_info$expression[log_oncogenes_info$log2FoldChange >0 ] <- 1
log_oncogenes_info$expression[log_oncogenes_info$log2FoldChange <0 ] <- 0
log_oncogenes_binary <- log_oncogenes_info[,c("gene.type","expression")]

#Separate based on gene type (oncogene, tumor suppressor, or both)
oncogenes_binary <- dplyr::filter(log_oncogenes_binary, grepl('oncogene', gene.type))
oncogenes_binary <- oncogenes_binary$expression

oncogenes_TSG_binary <- dplyr::filter(log_oncogenes_binary, grepl("oncogene_TSG", gene.type))
oncogenes_TSG_binary <- oncogenes_TSG_binary$expression

TSG_binary <- dplyr::filter(log_oncogenes_binary, grepl('TSG', gene.type))
TSG_binary <- TSG_binary$expression

#Create a dataframe stating how many genes are up- and downregulated for each gene type (oncogenes, oncogenes + TSG, TSG)
gene.type <- c("oncogene","oncogene","oncogene_TSG","oncogene_TSG","TSG","TSG")
gene.count <- c(sum(oncogenes_binary),length(oncogenes_binary)-sum(oncogenes_binary),
                sum(oncogenes_TSG_binary),length(oncogenes_TSG_binary)-sum(oncogenes_TSG_binary),
                sum(TSG_binary),
                length(TSG_binary)-sum(TSG_binary))
gene.condition <- c("TERT upregulated","TERT downregulated","TERT upregulated","TERT downregulated","TERT upregulated","TERT downregulated")
log_oncogenes_barchart <- data.frame(x=gene.type,y=gene.count, group=gene.condition)

#Plot the result in a bar chart
onco_plot <- ggplot(log_oncogenes_barchart, aes( x=x,y=y, fill = group)) + 
  geom_bar(position="stack", stat="identity") + scale_fill_manual(values=c("darkred","darkgreen"))

#-----------------------------------------------------------------------------------------------------

##PCA analysis of the samples
#Create a PDF file to store the results
pdf(paste(resultsdir,"ALL_PCA_v2.pdf",sep="/") ,width=6,height=7,paper='special')

#Specifying the dataset you want to look at (object) and the metadata it contains (intgroup)
object <- vst_dds
intgroup <- c("conditions","experiment")

#Finding back individual PC scores for the genes. summary(pc) can give you the % of variance each PC explains.
rv = rowVars(assay(object)) 
select = order(rv, decreasing=TRUE)[seq_len(min(10000, length(rv)))]
pc = prcomp(t(assay(object)[select,]))
loadings = as.data.frame(pc$rotation)
aload = -loadings
sweep(aload, 2, colSums(aload), "/")

#Generate a Scree plot, which visualises the % variance each PC explains The PC = paste0("PC", x:x ... might have to be adapted if your dataset generates a different number of PCs.)
var_explained_df <- data.frame(PC= paste0("PC",1:14),
                               var_explained=(pc$sdev)^2/sum((pc$sdev)^2))
var_explained_df <- var_explained_df[order(var_explained_df$var_explained,decreasing = TRUE),]
var_explained_df$PC <- factor(var_explained_df$PC, levels = var_explained_df$PC)

var_explained_df %>%
  ggplot(aes(x=PC,y=var_explained, group=1))+
  geom_point(size=4)+
  geom_line()+
  labs(title="Scree plot of PCA")

#This is a function to generate a PCA plot of your samples. It calculates PC scores for each gene and makes the PCA plot based on this.
plotPCA.dim <- function (object, intgroup = "conditions", ntop = 500, returnData = FALSE) 
{
  rv <- rowVars(assay(object))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
                                                     length(rv)))]
  pca <- prcomp(t(assay(object)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  if (!all(intgroup %in% names(colData(object)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }
  intgroup.df <- as.data.frame(colData(object)[, intgroup, drop = FALSE])
  group <- if (length(intgroup) > 1) {
    factor(apply(intgroup.df, 1, paste, collapse = " : "))
  }
  else {
    colData(object)[[intgroup]]
  }
  d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], PC3= pca$x[,3], PC4 =pca$x[,4],PC5=pca$x[,5], group = group, 
                  intgroup.df, name = dds@colData@listData[["experiment"]])
  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:3]
    return(d)
  }
   ggplot(d, aes(PC1, PC2, color = conditions, label = name)) +geom_point(size=3) + geom_label_repel(box.padding=0.5) + xlab(paste0("PC1: ",round(var_explained_df[1,2]*100,digits = 2),"%")) + ylab(paste0("PC2: ",round(var_explained_df[2,2]*100, digits = 2),"%"))
   #if you ever want to change which PC dimensions to look at, change the PC in the ggplot function. For example, swap out "PC2" for "PC3". This function can go up to PCA 5.
}

#Make the PCA plot based on your DESeq2 result
PCA_ALL <- plotPCA.dim(vst_dds)
PCA_ALL

#I now extract the PC1 scores for all genes
genes_PC1 <- aload[order(aload$PC1, decreasing=TRUE),]
genes_PC1 <- as.data.frame(aload$PC1)
genes_PC1$Gene <- rownames(aload)
colnames(genes_PC1) <- c("PC1", "Gene")

#I make a histogram to decide which PC1 values would be good cutoffs to decide if a gene significantly contributes to PC1
ggplot(genes_PC1, aes(x=PC1)) + geom_histogram(binwidth=0.0001)
#Good cut-off value is likely 0.015 and above or -0.010 or below
#so I make two datasets: genes with large positive PC1 scores and genes with large negative PC1 scores
genes_PC1_filtered_pos <- genes_PC1[genes_PC1$PC1>=0.015,]
genes_PC1_filtered_neg <- genes_PC1[genes_PC1$PC1 <=-0.010,]

#GO analysis of the genes with significant PC1 scores separated based on positive or negative contribution
ego_PC1_pos <- enrichGO(gene         = genes_PC1_filtered_pos$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

ego_PC1_neg <- enrichGO(gene         = genes_PC1_filtered_neg$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

#Visualisation of the results
PCA_pos_ALL <- barplot(ego_PC1_pos, showCategory = 15, title = "GO analysis of genes giving positive weight to PC1")
PCA_neg_ALL <- barplot(ego_PC1_neg, showCategory = 15, title = "GO analysis of genes giving negative weight to PC1")
PCA_pos_ALL
PCA_neg_ALL

#I again make a histogram, but now of PC2 scores, to decide which cut-offs to use to decide if a gene significantly contributes to PC2
genes_PC2 <- aload[order(aload$PC2, decreasing=TRUE),]
genes_PC2 <- as.data.frame(aload$PC2)
genes_PC2$Gene <- rownames(aload)
colnames(genes_PC2) <- c("PC2", "Gene")

ggplot(genes_PC2, aes(x=PC2)) + geom_histogram(binwidth=0.0001)

#Good cut-off value is likely 0.015 and above & -0.015 or below
#so I make two datasets: genes with large positive PC2 scores and genes with large negative PC2 scores
genes_PC2_filtered_pos <- genes_PC2[genes_PC2$PC2>=0.015,]
genes_PC2_filtered_neg <- genes_PC2[genes_PC2$PC2 <=-0.015,]

#GO analysis of the genes with significant PC2 scores separated based on positive or negative contribution
ego_PC2_pos <- enrichGO(gene         = genes_PC2_filtered_pos$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

ego_PC2_neg <- enrichGO(gene         = genes_PC2_filtered_neg$Gene,
                        OrgDb         = org.Hs.eg.db,
                        keyType       = 'SYMBOL',
                        ont           = "BP",
                        pAdjustMethod = "BH",
                        pvalueCutoff  = 1,
                        qvalueCutoff  = 0.05,
                        readable      = FALSE)

#And I visualize the results again
barplot(ego_PC2_pos, showCategory = 15, title = "GO analysis of genes giving positive weight to PC2")
barplot(ego_PC2_neg, showCategory = 15, title = "GO analysis of genes giving negative weight to PC2")

#I include the heatmap of the sample distances in the PCA analysis
sampleDists <- dist(t(assay(vst_dds)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

dev.off()
#--------------------------------------------------------------------------------------------------------

#Make a Venn diagram that compares the differential genes in LSCs to the differential genes in KCs and finds the overlap
log2_KC_genes <- read.table("/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/20220609/wt_vs_TERT_KC_genes_2_v3.tsv")
log2_KC_genes <- as.vector(log2_KC_genes[,1])
log2_LSC_genes <- read.table("/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/20220609/wt_vs_TERT_LSC_genes_2.v2.tsv")
log2_LSC_genes <- as.vector(log2_LSC_genes[,1])

#Plot this Venn diagram and export it to your results folder
venn <- venn.diagram(
  x = list(log2_KC_genes, log2_LSC_genes),
  category.names = c("KC" , "LSC " ),
  filename = "venn_all",                          #set filename to NULL if you want the result printed in your R session
  output=TRUE, imagetype="png" ,
  height = 1080 , 
  width = 1920 , 
  resolution = 300, lwd=1, compression="lzw",  col=c('#21908dff', '#fde725ff'),
  fill = c(alpha('#21908dff',0.3), alpha('#fde725ff',0.3)),
)
grid.draw(venn) #will draw the Venn diagram in your R session if the filename is NULL
unlink("*.log") #will remove the logging files that come with making a Venn diagram

#The code below will make an Upset plot showing if genes are upregulated or downregulated in LSCs and KCs, and if these genes show large overlap
#I first import the DESeq2 result of the KC analysis
DESeq_KC <- read.csv("/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/20220609/wt_vs_TERT_KC_DESeq2_v3.tsv", header = TRUE, sep= "\t")
DESeq_KC$Gene.name <- rownames(DESeq_KC)
#Then, the DESeq2 result of the LSC analysis
DESeq_LSC <- read.csv("/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/20220609/wt_vs_TERT_LSC_DESeq2.v2.tsv", header = TRUE, sep= "\t")
DESeq_LSC$Gene.name <- rownames(DESeq_LSC)
#Then, I join these together
DESeq_all <- inner_join(DESeq_KC, DESeq_LSC, by = "Gene.name")
rownames(DESeq_all) <- DESeq_all$Gene.name

#I now extract from the joined DESeq2 table the log2Fold changes in the KC analysis (log2FoldChange.x) and in the LSC analysis (log2FoldChange.y).
binary <- as.data.frame(DESeq_all[, c("log2FoldChange.x", "log2FoldChange.y")])
colnames(binary) <- c("KC", "LSC")

#I now assign each gene a score based on these log2FC changes.
#Starting with the log2FC for the KC condition:
# if the log2FC > 0, then the gene is higher expressed in TERT KCs. Therefore, KC_TERT_HIGH gets assigned a score of 1, and KC_TERT_LOW gets a score of 0.
binary$KC_TERT_HIGH[binary$KC > 0 ] <- 1
binary$KC_TERT_LOW[binary$KC > 0 ] <- 0

#If the log2FC < 0, then the gene is lower expressed in TERT KCs. KC_TERT_LOW gets a score of 1 and KC_TERT_HIGH gets a score of 0.
binary$KC_TERT_LOW[binary$KC < -0 ] <- 1
binary$KC_TERT_HIGH[binary$KC < -0 ] <- 0

#I repeat the above procedure for the log2FC values in the LSC condition
binary$LSC_TERT_HIGH[binary$LSC > 0 ] <- 1
binary$LSC_TERT_LOW[binary$LSC > 0 ] <- 0

binary$LSC_TERT_LOW[binary$LSC < -0 ] <- 1
binary$LSC_TERT_HIGH[binary$LSC < -0 ] <- 0

#Now, I can make an Upset plot showing the expression patterns of genes across both individual analyses.
pdf(paste(resultsdir,'upset_both_conditions_v2_logfilter.pdf',sep="/") ,width=6,height=7,paper='special')
upset(binary)
dev.off()

#-----------------------------------------------------------------------------------------------------------

#I now make a heatmap of genes differential in LSCs, in KCs, or in both.
#I start with importing the differential genes of the individual analyses and assigning them the cell type they came from.
#LSC
diff_LSC <- read.csv("/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/20220609/wt_vs_TERT_LSC_genes_2.v2.tsv", header = FALSE, sep= "\t")
colnames(diff_LSC) <- c("Gene.name")
diff_LSC$Cell.type <- "LSC"

#KC
diff_KC <- read.csv("/scratch/szande_jarts/diff_gene_expression_wt_vs_TERT/20220609/wt_vs_TERT_KC_genes_2_v3.tsv", header = FALSE, sep= "\t")
colnames(diff_KC) <- c("Gene.name")
diff_KC$Cell.type <- "KC"

#I now join these tables together, which will result in a data frame containing only the genes that are differential in both individual analyses.
#I assign these the cell type "LSC+KC"
diff_both <- inner_join(diff_LSC , diff_KC, by= "Gene.name")
diff_both <- as.data.frame(diff_both[,1])
colnames(diff_both) <- c("Gene.name")
diff_both$Cell.type <- "LSC + KC"

#The genes that are differential in both conditions now appear thrice: once in both of the individual analyses, and once in the table of genes differential in both analyses.
#Therefore, I make a dataframe of the KC and LSC analysis containing only genes that are not duplicated (and are therefore only differential in one cell type).
diff_unique <- NULL
diff_unique <- rbind(diff_unique, diff_LSC, diff_KC)
diff_unique <- distinct(diff_unique, Gene.name, .keep_all = TRUE)

#Now, I combine the data to get a data frame of all differential genes with their cell type annotation.
diff_all <- rbind(diff_unique, diff_both)

#I then couple these genes to their z-scores in the overall analysis
z_values_diff <- as.data.frame(subset(z_new, rownames(z_new) %in% diff_all[,1]))
z_values_diff$Gene.name <- rownames(z_values_diff)
diff_all_values <- inner_join(diff_all, z_values_diff, by = "Gene.name")

#I make the sidebar annotation, which shows the cell type that the row in the heatmap (the gene) is differential in.
colours <- list(celltype = c("KC" = "purple", "LSC" = "navy", "LSC + KC" = "gold"))
ha = HeatmapAnnotation(celltype = diff_all_values$Cell.type, which = "row", col=colours)

#Then, I make an annotation bar that shows which condition each sample belongs to (primary or TERT)
ann <- data.frame(colData$condition)
colnames(ann) <- c('Condition')
colours <- list('Condition' = c('primary' = 'pink', 'TERT' = 'green'))
colAnn <- HeatmapAnnotation(df = ann,
                            which = 'col',
                            col = colours,
                            annotation_width = unit(c(1, 4), 'cm'),
                            gap = unit(1, 'mm'))

#I annotate some genes by randomly selecting 7 genes of each cell type (LSC, KC, or both).
#set.seed is used to make the random sampling reproducible.
set.seed(1)
KC <- diff_KC[sample(nrow(diff_KC), 7), ]
KC <- KC[,1]
LSC <- diff_LSC[sample(nrow(diff_LSC), 7), ]
LSC <- LSC[,1]
BOTH <- diff_both[sample(nrow(diff_both), 7), ]
BOTH <- BOTH[,1]
anno_names <- c(KC,LSC,BOTH)

#I now make the labels of the randomly chosen genes
anno_combrow <- which(rownames(z_values_diff)%in% anno_names, arr.ind = TRUE)
anno_comb = anno_mark(at = anno_combrow, labels = anno_names , which = "row")

#Now, the heatmap can be made using the cell type, sample type, and gene name annotations.
cellclusterHT <-Heatmap(
  diff_all_values[3:16], name = "z-score",
  left_annotation=ha,
  bottom_annotation=colAnn, column_title = "Heatmap of all differential genes in at least one condition")
  + rowAnnotation(mark = anno_comb)
cellclusterHT <- Heatmap(diff_all_values[3:14], name="z-score", 
                         column_title = "Heatmap of all differential genes in at least one condition",
                         left_annotation=ha,
                         bottom_annotation=colAnn,
                         col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_comb)

z_values_diff <- z_values_diff[row_order(cellclusterHT),]
anno_names <- anno_names[order(match(anno_names,rownames(z_values_diff)))]
anno_combrow <- which(rownames(z_values_diff)%in% anno_names, arr.ind = TRUE)
anno_comb = anno_mark(at = anno_combrow, labels = anno_names , which = "row")

pdf(paste(resultsdir,'combined_heatmap.v2.pdf',sep="/") ,width=7,height=7,paper='special')

cellclusterHT <- Heatmap(diff_all_values[3:16], name="z-score", 
                         column_title = "Heatmap of all differential genes in at least one condition",
                         left_annotation=ha,
                         bottom_annotation=colAnn,
                         col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_comb)

draw(cellclusterHT)
dev.off()

#If you ever want to split the heatmap by cell type, you can use the following code:
#cellclusterHT <-Heatmap(
  #diff_all_values[3:14], name = "z-score",
  #left_annotation=ha, row_order = order(diff_all_values$Cell.type),
  #row_split = diff_all_values$Cell.type, row_gap = unit(5, "mm"))

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Find the TPM values for a set of epithelial markers by means of the same loop as before
epithelial <- c("KRT1", "KRT3","KRT10", "KRT12","KRT13" ,
                "KRT14", "KRT15", "KRT19", "KLF4", "KLF5","KLF6","KLF7")

df_epithelial <- NULL

for (xx in unique(epithelial)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial <- rbind(df_epithelial, df)
  df_epithelial$condition = factor(df_epithelial$condition, condition_vector)
}

#Plot the epithelial markers on the heatmap of differential genes as done before
epithelial_row <- which(rownames(z_logfilter)%in% epithelial, arr.ind = TRUE)
anno_epi = anno_mark(at =epithelial_row, labels = epithelial , which = "row")
HTepi <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)
row_order(HTepi)
z_logfilter <- z_logfilter[row_order(HTepi),]
epithelial <- epithelial[order(match(epithelial,rownames(z_logfilter)))]
epithelial_row <- which(rownames(z_logfilter)%in% epithelial, arr.ind = TRUE)
anno_epi = anno_mark(at =epithelial_row, labels = epithelial , which = "row")
HTepi <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi)\

p_epi1 <- ggplot(df_epithelial, aes(x = gene, y = log10(TPM+1))) + #this might give a warning in R stating that the expected token is 'LPAREN'. Not sure how it got there, but it does not influence the code so it can be ignored.
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers")

#I do the same for a second set of markers
epithelial_2 <- c("GPHA2", "CPVL","CXCL14", "MMP10","S100A2" ,"SOX7",
                  "SOX9", "FOXE1", "DLX4", "DMRTA2", "GATA3")

df_epithelial_2 <- NULL

for (xx in unique(epithelial_2)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial_2 <- rbind(df_epithelial_2, df)
  df_epithelial_2$condition = factor(df_epithelial_2$condition, condition_vector)
}

epithelial_2_row <- which(rownames(z_logfilter)%in% epithelial_2, arr.ind = TRUE)
anno_epi_2 = anno_mark(at =epithelial_2_row, labels = epithelial_2 , which = "row")
HTepi2 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_2)
row_order(HTepi2)
z_logfilter <- z_logfilter[row_order(HTepi2),]
epithelial_2 <- epithelial_2[order(match(epithelial_2,rownames(z_logfilter)))]
epithelial_2_row <- which(rownames(z_logfilter)%in% epithelial_2, arr.ind = TRUE)
anno_epi_2 = anno_mark(at =epithelial_2_row, labels = epithelial_2 , which = "row")
HTepi2 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_2)

p_epi2 <- ggplot(df_epithelial_2, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers")

#I do the analysis a third time for more general epithelial transcription factors (and some cell type specific transcription factors)
epithelial_3 <- c("JUN","JUNB","TFAP2A","GRHL1","GRHL2", "ETS2","ELF3","SMAD3","KERA","SLC4A11", "RUNX1", "CALML3", "FOSL2","CEBPA","EHF")

df_epithelial_3 <- NULL

for (xx in unique(epithelial_3)) {
  val <- TPM[rownames(TPM)==xx,]
  val2 <- as.vector(unname(val))
  if (is.na(val[1,1])==T) next
  val2 <- t(val2)
  val3 <- val2[,1]
  df <- data.frame(TPM=val3,condition = colnames(val),gene=xx)
  df_epithelial_3 <- rbind(df_epithelial_3, df)
  df_epithelial_3$condition = factor(df_epithelial_3$condition, condition_vector)
}

epithelial_3_row <- which(rownames(z_logfilter)%in% epithelial_3, arr.ind = TRUE)
anno_epi_3 = anno_mark(at =epithelial_3_row, labels = epithelial_3 , which = "row")
HTepi3 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_3)
row_order(HTepi3)
z_logfilter <- z_logfilter[row_order(HTepi3),]
epithelial_3 <- epithelial_3[order(match(epithelial_3,rownames(z_logfilter)))]
epithelial_3_row <- which(rownames(z_logfilter)%in% epithelial_3, arr.ind = TRUE)
anno_epi_3 = anno_mark(at =epithelial_3_row, labels = epithelial_3 , which = "row")
HTepi3 <- Heatmap(z_logfilter, name="z-score", column_title = "Heatmap indicating epithelial markers", col = f4,  row_names_gp = gpar(fontsize = 5)) + rowAnnotation(mark = anno_epi_3)

p_epi3 <- ggplot(df_epithelial_3, aes(x = gene, y = log10(TPM+1))) +
  geom_bar(
    aes(fill = condition),
    stat = "identity" , position = position_dodge(0.8),
    width = 0.7) + ggtitle("Epithelial markers")

#I export the TPM plots and heatmaps of all investigated epithelial/LSC markers
pdf(paste(resultsdir,'ALL_epithelial markers.pdf',sep="/") ,width=7,height=7,paper='special')
draw(HTepi)
p_epi1
draw(HTepi2)
p_epi2
draw(HTepi3)
p_epi3
dev.off()

#Close off the results PDF
dev.off()

#END
```
